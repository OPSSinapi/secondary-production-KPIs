<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sinapi Biomedical Operations Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <style>
    :root {
        --primary-blue: #3498db;
        --primary-dark-blue: #2980b9;
        --primary-orange: #f39c12;
        --primary-purple: #9b59b6;
        --text-dark: #2c3e50;
        --text-light: #7f8c8d;
        --border-color: #ecf0f1;
        --timeline-blue: #3498db;
        --timeline-orange: #e67e22;
        --timeline-red: #e74c3c;
        --timeline-purple: #9b59b6;
        --success-color: #27ae60;
        --warning-color: #f39c12;
        --danger-color: #c0392b;
        --active-bg: #eafaf1;
        --standby-bg: #fef9e7;
        --error-bg: #fdeaea;
    }

    * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
    }

    body {
        font-family: Arial, sans-serif;
        background-color: #f8f9fa;
        color: var(--text-dark);
    }

    /* Header styles */
    .header {
        background-color: var(--primary-dark-blue);
        color: white;
        padding: 0 20px;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .header h1 {
        font-size: 20px;
    }

    .date-controls {
        display: flex;
        align-items: center;
        gap: 10px;
    }

    .date-filter {
        background-color: rgba(255, 255, 255, 0.2);
        padding: 5px 10px;
        border-radius: 5px;
        font-size: 14px;
    }

    .date-range-btn, .period-btn, .refresh-btn {
        background-color: var(--primary-blue);
        color: white;
        border: none;
        border-radius: 5px;
        padding: 5px 10px;
        cursor: pointer;
        font-size: 12px;
    }

    .refresh-btn {
        width: 30px;
        height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    /* Date picker dropdown */
    .date-picker-dropdown {
        position: absolute;
        top: 60px;
        right: 20px;
        background-color: white;
        border: 1px solid var(--border-color);
        border-radius: 5px;
        padding: 15px;
        z-index: 999;
        box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        display: none;
        width: 320px;
    }

    .date-picker-dropdown.show {
        display: block;
    }

    .date-picker-dropdown label {
        display: block;
        margin-bottom: 5px;
        font-size: 14px;
    }

    .date-picker-dropdown input[type="date"] {
        width: 100%;
        padding: 8px;
        margin-bottom: 10px;
        border: 1px solid var(--border-color);
        border-radius: 3px;
    }

    .date-picker-dropdown button {
        background-color: var(--primary-blue);
        color: white;
        border: none;
        border-radius: 3px;
        padding: 8px 15px;
        cursor: pointer;
        width: 100%;
        margin-top: 10px;
    }

    .cycle-selection {
        margin-top: 15px;
        padding-top: 15px;
        border-top: 1px solid var(--border-color);
    }

    .cycle-selection select {
        width: 100%;
        padding: 8px;
        margin-top: 5px;
        border: 1px solid var(--border-color);
        border-radius: 3px;
    }

    /* KPI Summary */
    .kpi-summary {
        background-color: white;
        border-radius: 5px;
        margin: 15px;
        box-shadow: 0 2px 6px rgba(0,0,0,0.05);
    }

    .kpi-summary-label {
        padding: 10px 15px;
        font-size: 16px;
        font-weight: bold;
        border-bottom: 1px solid var(--border-color);
    }

    .kpi-cards {
        display: flex;
        flex-wrap: wrap;
        justify-content: space-between;
        padding: 10px;
        gap: 10px;
    }

    .kpi-card {
        flex: 1;
        min-width: 180px;
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 15px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
    }

    .kpi-title {
        font-size: 14px;
        color: var(--text-light);
        margin-bottom: 10px;
    }

    .kpi-value {
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .kpi-value-number {
        font-size: 22px;
        font-weight: bold;
    }

    .kpi-trend {
        font-size: 14px;
        display: flex;
        align-items: center;
        gap: 2px;
    }

    .trend-up {
        color: var(--success-color);
    }

    .trend-down {
        color: var(--danger-color);
    }

    /* Loading spinner */
    .loading-container {
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 20px;
        height: 200px;
        width: 100%;
    }

    .loading-spinner {
        border: 5px solid rgba(0, 0, 0, 0.1);
        border-radius: 50%;
        border-top: 5px solid var(--primary-blue);
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
/* 
        ======================================
        MAIN DASHBOARD GRID
        ======================================
        */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: auto auto;
            gap: 10px;
            padding: 0 15px;
            margin-bottom: 15px;
        }

        /* 
        ======================================
        LINE CARDS
        ======================================
        */
        .line-card {
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            overflow: hidden;
            width: 100%;
            height: 100%;
            position: relative;
        }

        .line-card-header {
            padding: 5px 15px;
            font-size: 16px;
            font-weight: bold;
            color: white;
            height: 35px;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .card-title {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .card-actions {
            display: flex;
            align-items: center;
        }

        .enlarge-icon {
            cursor: pointer;
            margin-left: 8px;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .enlarge-icon:hover {
            opacity: 1;
        }

        .blue-header {
            background-color: var(--primary-blue);
        }

        .orange-header {
            background-color: var(--primary-orange);
        }

        .purple-header {
            background-color: var(--primary-purple);
        }

        .line-card-content {
            padding: 10px 15px;
        }

        .variant-info {
            background-color: #f5f7fa;
            border-radius: 3px;
            padding: 5px 10px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 30px;
        }

        .variant-label {
            font-size: 12px;
            color: var(--text-dark);
        }

        .variant-name {
            font-weight: bold;
            margin-left: 5px;
        }

        .status-badge {
            border-radius: 5px;
            padding: 2px 10px;
            font-size: 11px;
            font-weight: bold;
            text-align: center;
            width: 70px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .status-active {
            background-color: var(--active-bg);
            color: var(--success-color);
        }

        .status-standby {
            background-color: var(--standby-bg);
            color: var(--warning-color);
        }

        .status-ended {
            background-color: var(--standby-bg);
            color: var(--warning-color);
        }

        /* 
        ======================================
        VARIANT HISTORY
        ======================================
        */
        .variant-history {
            background-color: #f5f7fa;
            border-radius: 3px;
            padding: 5px 10px;
            margin-bottom: 10px;
            height: 60px;
        }

        .history-label {
            font-size: 11px;
            font-weight: bold;
            color: var(--text-light);
            margin-bottom: 5px;
        }

        .timeline-container {
            background-color: white;
            border-radius: 2px;
            padding: 5px;
            height: 25px;
            position: relative;
        }

        /* 
        ======================================
        COMBINED VARIANT DISPLAY
        ======================================
        */
        .variant-combined {
            background-color: #f5f7fa;
            border-radius: 3px;
            padding: 5px 10px;
            margin-bottom: 10px;
        }

        .variant-combined .variant-info {
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 30px;
        }

        .variant-combined .timeline-container {
            height: 20px;
            padding: 2px;
        }

        .timeline-segment {
            position: absolute;
            height: 15px;
            top: 5px;
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
        }

        /* 
        ======================================
        EXPLICIT GRID POSITIONING
        ======================================
        */
        .grid-position-1-1 { grid-row: 1; grid-column: 1; }
        .grid-position-1-2 { grid-row: 1; grid-column: 2; }
        .grid-position-1-3 { grid-row: 1; grid-column: 3; }
        .grid-position-1-4 { grid-row: 1; grid-column: 4; }
        .grid-position-2-1 { grid-row: 2; grid-column: 1; }
        .grid-position-2-2 { grid-row: 2; grid-column: 2; }
        .grid-position-2-3 { grid-row: 2; grid-column: 3; }
        .grid-position-2-4 { grid-row: 2; grid-column: 4; }

        /* 
        ======================================
        KPI METRICS GRID
        ======================================
        */
        .metrics-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .metric-card {
            background-color: #f5f7fa;
            border-radius: 3px;
            padding: 10px;
            height: 60px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .metric-title {
            font-size: 12px;
            color: var(--text-dark);
        }

        .metric-value {
            font-size: 18px;
            font-weight: bold;
            text-align: right;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 5px;
        }

        .metric-trend {
            font-size: 12px;
        }

        .value-good {
            color: var(--success-color);
        }

        .value-warning {
            color: var(--warning-color);
        }

        .value-danger {
            color: var(--danger-color);
        }

        /* 
        ======================================
        DIVIDER
        ======================================
        */
        .divider {
            height: 2px;
            background-color: var(--border-color);
            margin: 10px 0;
        }

        /* 
        ======================================
        TABLE FOR POPUP LINE
        ======================================
        */
        .runs-table-container {
            background-color: #f5f7fa;
            border-radius: 3px;
            padding: 10px;
            margin-top: 10px;
        }

        .runs-table-title {
            font-size: 12px;
            font-weight: bold;
            color: var(--text-dark);
            margin-bottom: 10px;
        }

        .runs-table {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0 5px;
        }

        .runs-table th {
            background-color: #ecf0f1;
            padding: 5px;
            text-align: left;
            font-size: 10px;
            color: var(--text-light);
            border-radius: 2px;
        }

        .runs-table td {
            background-color: white;
            padding: 5px;
            font-size: 10px;
            border-radius: 2px;
        }

        /* 
        ======================================
        ERROR MESSAGE
        ======================================
        */
        .error-message {
            background-color: var(--error-bg);
            color: var(--danger-color);
            padding: 15px;
            margin: 10px 15px;
            border-radius: 5px;
            text-align: center;
        }

        /* 
        ======================================
        DEBUG LOG
        ======================================
        */
        .debug-log {
            background-color: #f8f9fa;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            margin: 10px 15px;
            padding: 10px;
            max-height: 200px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 12px;
        }

        .debug-log-entry {
            margin-bottom: 5px;
            padding: 3px;
            border-bottom: 1px solid #eee;
        }

        .debug-log-entry.error {
            color: var(--danger-color);
            font-weight: bold;
        }

        .debug-log-entry.warning {
            color: var(--warning-color);
        }

        .debug-log-entry.info {
            color: var(--text-dark);
        }
        /* 
        ======================================
        MODAL / DETAIL VIEW
        ======================================
        */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 1000;
            display: none;
            justify-content: center;
            align-items: center;
        }

        .modal-overlay.show {
            display: flex;
        }

        /* Improved Modal Styling */
        .modal-content {
            background-color: #f8f9fa;
            border-radius: 8px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            width: 95%;
            max-width: 1600px;
            height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .modal-header {
            padding: 15px 20px;
            background-color: var(--primary-dark-blue);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 18px;
            font-weight: bold;
        }

        .modal-close {
            font-size: 22px;
            color: white;
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0.8;
            transition: opacity 0.2s;
        }

        .modal-close:hover {
            opacity: 1;
        }

        .modal-body {
            flex: 1;
            overflow: hidden;
            padding: 15px 20px;
        }

        /* Improved compact charts */
        .detail-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 15px;
            height: calc(100% - 60px); /* Subtract date nav height */
        }

        .detail-metric-card {
            background-color: white;
            border-radius: 6px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
            height: 100%;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            padding: 12px;
        }

        .chart-container {
            flex: 1;
            position: relative;
            min-height: 0;
            background-color: #ffffff;
            border-radius: 4px;
            padding: 10px;
            margin-top: 5px;
        }

        .detail-metric-footer {
            margin-top: 10px;
            max-height: 180px;
            overflow-y: auto;
            background-color: #ffffff;
            border-radius: 4px;
            padding: 10px;
        }

        .chart-row {
            display: flex;
            gap: 15px;
            height: 100%;
        }

        .pie-chart-container {
            flex: 1;
            height: 100%;
            position: relative;
            background-color: #ffffff;
            border-radius: 4px;
            padding: 5px;
        }

        .detail-metric-header {
            font-size: 14px;
            font-weight: bold;
            color: var(--text-dark);
            padding-bottom: 5px;
            border-bottom: 1px solid var(--border-color);
        }

        /* 
        ======================================
        DATE NAVIGATION
        ======================================
        */
        .date-nav {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            background-color: white;
            border-radius: 6px;
            padding: 10px 15px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.05);
        }

        .date-range-display {
            font-size: 15px;
            font-weight: bold;
            color: var(--text-dark);
        }

        .date-nav-controls {
            display: flex;
            gap: 10px;
        }

        .date-nav-btn {
            background-color: var(--primary-blue);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 13px;
            min-width: 150px; /* Increased min-width to prevent text cutoff */
            justify-content: center; /* Center content in button */
            white-space: nowrap; /* Prevent text wrapping */
        }

        .date-nav-btn:hover {
            background-color: #2980b9;
        }

        /* 
        ======================================
        TOGGLE BUTTONS
        ======================================
        */
        .toggle-container {
            display: flex;
            gap: 8px;
            margin-bottom: 8px;
            flex-wrap: wrap; /* Allow wrapping for multiple buttons */
        }

        .toggle-btn {
            background-color: #e8e8e8;
            border: none;
            border-radius: 4px;
            padding: 4px 8px;
            cursor: pointer;
            font-size: 11px;
        }

        .toggle-btn.active {
            background-color: var(--primary-blue);
            color: white;
        }

        .top-items-list {
            background-color: white;
            border-radius: 4px;
            overflow-y: visible; /* Ensure all items are visible */
            max-height: none; /* No height limit in the list container */
        }

        .top-item {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #eee;
        }

        .top-item:last-child {
            border-bottom: none;
        }

        .top-item-label {
            font-weight: bold;
            font-size: 11px;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            margin-right: 8px;
        }

        .top-item-value {
            color: var(--text-light);
            font-size: 11px;
            flex-shrink: 0;
        }

        /* Specific adjustment for scrap/downtime detail sections */
        .detail-metric-card:nth-child(3) .chart-container,
        .detail-metric-card:nth-child(4) .chart-container {
            flex: 0.4; /* Even smaller charts for scrap and downtime sections */
        }

        .detail-metric-card:nth-child(3) .detail-metric-footer,
        .detail-metric-card:nth-child(4) .detail-metric-footer {
            max-height: 200px; /* Taller footers for scrap and downtime sections */
        }

        /* 
        ======================================
        RESPONSIVE LAYOUTS
        ======================================
        */
        /* Special Cases */
        .card-double-height {
            grid-row: span 2;
        }

        /* Base product line cards in same column */
        .base-product-first {
            grid-column-start: var(--column-start);
        }

        .base-product-same-column {
            grid-column-start: var(--column-start);
        }

        @media (max-width: 1279px) {
            .dashboard-grid {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .card-double-height {
                grid-column: span 1;
            }
            
            .detail-metrics {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 767px) {
            .header {
                flex-direction: column;
                height: auto;
                padding: 10px;
            }
            
            .date-controls {
                margin-top: 10px;
                width: 100%;
                justify-content: space-between;
            }
            
            .kpi-cards {
                flex-direction: column;
                height: auto;
                gap: 5px;
            }
            
            .kpi-summary {
                height: auto;
            }
            
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
            
            .modal-content {
                width: 95%;
                max-height: 95vh;
            }
            
            .modal-title {
                font-size: 16px;
            }
            
            .chart-container {
                height: 200px;
            }
        }

        /* 
        ======================================
        CHART PLACEHOLDERS
        ======================================
        */
        .chart-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .bar-container {
            flex: 1;
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            padding: 10px 0;
        }

        .chart-bar {
            width: 30px;
            background-color: var(--primary-blue);
            border-radius: 2px 2px 0 0;
        }

        .downtime-bar.high {
            background-color: var(--danger-color);
        }

        .downtime-bar.medium {
            background-color: var(--warning-color);
        }

        .x-axis-labels {
            display: flex;
            justify-content: space-around;
            font-size: 10px;
            color: var(--text-light);
            padding: 5px 0;
        }

        .line-chart-container {
            flex: 1;
            position: relative;
        }

        .line-chart {
            width: 100%;
            height: 100%;
        }

        .line-path {
            fill: none;
            stroke: var(--primary-blue);
            stroke-width: 2;
        }

        .scrap-line {
            stroke: var(--danger-color);
        }

        .data-point {
            fill: var(--primary-blue);
        }

        .scrap-point {
            fill: var(--danger-color);
        }

        .chart-subtitle {
            font-size: 12px;
            color: var(--text-dark);
            margin-bottom: 5px;
        }

        .trend-chart-container {
            flex: 1.5;
            display: flex;
            flex-direction: column;
        }

        .pie-chart-placeholder {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .list-title {
            font-size: 11px;
            font-weight: bold;
            color: var(--text-dark);
            margin-bottom: 5px;
        }
    </style>
</head>

<body>
    <!-- Header Section -->
    <header class="header">
        <h1>Sinapi Biomedical Operations Dashboard</h1>
        <div class="date-controls">
            <button class="date-nav-btn" id="prevPeriodButton"><i class="fas fa-chevron-left"></i></button>
            <div class="date-filter" id="dateRangeDisplay">Loading...</div>
            <button class="date-nav-btn" id="nextPeriodButton"><i class="fas fa-chevron-right"></i></button>
            <button class="date-range-btn" id="dateRangeButton">Select Dates</button>
            <button class="period-btn" id="periodToggle">Weekly</button>
            <button class="refresh-btn" id="refreshButton"><i class="fas fa-sync-alt"></i></button>
        </div>
    </header>

    <!-- Date Range Picker Dropdown -->
    <div class="date-picker-dropdown" id="datePickerDropdown">
        <label for="startDate">Start Date:</label>
        <input type="date" id="startDate" name="startDate">
        <label for="endDate">End Date:</label>
        <input type="date" id="endDate" name="endDate">
        
        <div class="cycle-selection">
            <label for="cycleStartDay">Select Week Cycle:</label>
            <select id="cycleStartDay">
                <option value="1">Monday to Sunday</option>
                <option value="2">Tuesday to Monday</option>
                <option value="3">Wednesday to Tuesday</option>
                <option value="4">Thursday to Wednesday</option>
                <option value="5">Friday to Thursday</option>
                <option value="6">Saturday to Friday</option>
                <option value="0">Sunday to Saturday</option>
            </select>
            <div style="display: flex; gap: 10px; margin-top: 10px;">
                <button id="applyDateRange" style="flex: 1;">Apply</button>
                <button id="applyAndRememberCycle" style="flex: 1; background-color: var(--primary-dark-blue);">Apply & Remember</button>
            </div>
        </div>
    </div>

    <!-- KPI Summary Section -->
    <div class="kpi-summary">
        <div class="kpi-summary-label">Plant-wide Performance</div>
        <div class="kpi-cards" id="kpiSummary">
            <!-- KPI cards will be inserted here by JavaScript -->
            <div class="loading-container">
                <div class="loading-spinner"></div>
            </div>
        </div>
    </div>
    
    <!-- Main Dashboard Grid -->
    <div class="dashboard-grid" id="dashboardGrid">
        <!-- Loading spinner initially -->
        <div class="loading-container">
            <div class="loading-spinner"></div>
        </div>
    </div>

    <!-- Debug Log (hidden by default) -->
    <div class="debug-log" id="debugLog" style="display: none;">
        <div class="debug-log-entry info">Debug log initialized.</div>
    </div>

    <!-- Detail View Modal -->
    <div class="modal-overlay" id="detailModal">
        <div class="modal-content">
            <div class="modal-header">
                <div class="modal-title" id="modalTitle">SCD: Apelele Details</div>
                <button class="modal-close" id="modalClose">&times;</button>
            </div>
            <div class="modal-body">
                <!-- Date Navigation -->
                <div class="date-nav">
                    <div class="date-range-display" id="modalDateRange">March 18-25, 2025</div>
                    <div class="date-nav-controls">
                        <button class="date-nav-btn" id="prevWeekBtn"><i class="fas fa-chevron-left"></i> Previous Week</button>
                        <button class="date-nav-btn" id="nextWeekBtn">Next Week <i class="fas fa-chevron-right"></i></button>
                    </div>
                </div>
                
                <!-- Detail Metrics Grid -->
                <div class="detail-metrics">
                    <!-- Schedule Attainment -->
                    <div class="detail-metric-card">
                        <div class="detail-metric-header">Schedule Attainment</div>
                        <div class="chart-container" id="scheduleAttainmentChart">
                            <!-- Bar chart will be rendered here by JS -->
                            <div class="chart-placeholder">
                                <div class="bar-container">
                                    <div class="chart-bar" style="height: 70%"></div>
                                    <div class="chart-bar" style="height: 55%"></div>
                                    <div class="chart-bar" style="height: 65%"></div>
                                    <div class="chart-bar" style="height: 45%"></div>
                                    <div class="chart-bar" style="height: 70%"></div>
                                    <div class="chart-bar" style="height: 60%"></div>
                                    <div class="chart-bar" style="height: 80%"></div>
                                </div>
                                <div class="x-axis-labels">
                                    <span>Mar 18</span>
                                    <span>Mar 19</span>
                                    <span>Mar 20</span>
                                    <span>Mar 21</span>
                                    <span>Mar 22</span>
                                    <span>Mar 23</span>
                                    <span>Mar 24</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Labour Cost per Unit -->
                    <div class="detail-metric-card">
                        <div class="detail-metric-header">Labour Cost per Unit</div>
                        <div class="toggle-container">
                            <button class="toggle-btn active" id="labourCostBtn">Labour Cost</button>
                            <button class="toggle-btn" id="unitCostBtn">Cost Per Unit</button>
                        </div>
                        <div class="chart-container" id="labourCostChart">
                            <!-- Line chart will be rendered here by JS -->
                            <div class="chart-placeholder">
                                <div class="line-chart-container">
                                    <svg width="100%" height="80%" class="line-chart">
                                        <polyline points="10,80 20,70 30,75 40,65 50,55 60,60 70,50" class="line-path"></polyline>
                                        <circle cx="10" cy="80" r="4" class="data-point"></circle>
                                        <circle cx="20" cy="70" r="4" class="data-point"></circle>
                                        <circle cx="30" cy="75" r="4" class="data-point"></circle>
                                        <circle cx="40" cy="65" r="4" class="data-point"></circle>
                                        <circle cx="50" cy="55" r="4" class="data-point"></circle>
                                        <circle cx="60" cy="60" r="4" class="data-point"></circle>
                                        <circle cx="70" cy="50" r="4" class="data-point"></circle>
                                    </svg>
                                </div>
                                <div class="x-axis-labels">
                                    <span>Mar 18</span>
                                    <span>Mar 19</span>
                                    <span>Mar 20</span>
                                    <span>Mar 21</span>
                                    <span>Mar 22</span>
                                    <span>Mar 23</span>
                                    <span>Mar 24</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Scrap Percentage with Pie Chart -->
                    <div class="detail-metric-card">
                        <div class="detail-metric-header">Scrap Analysis</div>
                        <div class="toggle-container">
                            <button class="toggle-btn active" id="scrapQtyBtn">By Quantity</button>
                            <button class="toggle-btn" id="scrapCostBtn">By Cost</button>
                        </div>
                        <div class="chart-row">
                            <div class="trend-chart-container">
                                <div class="chart-subtitle">Scrap Percentage Trend</div>
                                <div class="chart-container" id="scrapPercentageChart">
                                    <!-- Trend line chart will be rendered here by JS -->
                                    <div class="chart-placeholder">
                                        <svg width="100%" height="80%" class="line-chart">
                                            <polyline points="10,70 20,65 30,75 40,60 50,65 60,58 70,55" class="line-path scrap-line"></polyline>
                                            <circle cx="10" cy="70" r="4" class="data-point scrap-point"></circle>
                                            <circle cx="20" cy="65" r="4" class="data-point scrap-point"></circle>
                                            <circle cx="30" cy="75" r="4" class="data-point scrap-point"></circle>
                                            <circle cx="40" cy="60" r="4" class="data-point scrap-point"></circle>
                                            <circle cx="50" cy="65" r="4" class="data-point scrap-point"></circle>
                                            <circle cx="60" cy="58" r="4" class="data-point scrap-point"></circle>
                                            <circle cx="70" cy="55" r="4" class="data-point scrap-point"></circle>
                                        </svg>
                                    </div>
                                </div>
                            </div>
                            <div class="pie-chart-container">
                                <div class="chart-subtitle">Reject Distribution</div>
                                <div id="rejectPieChart">
                                    <!-- Pie chart will be rendered here by JS -->
                                    <div class="pie-chart-placeholder">
                                        <svg width="100%" height="100%" viewBox="0 0 100 100">
                                            <circle cx="50" cy="50" r="40" fill="#f5f7fa" />
                                            <path d="M 50 50 L 50 10 A 40 40 0 0 1 85 35 Z" fill="#3498db" />
                                            <path d="M 50 50 L 85 35 A 40 40 0 0 1 65 88 Z" fill="#f39c12" />
                                            <path d="M 50 50 L 65 88 A 40 40 0 0 1 20 75 Z" fill="#9b59b6" />
                                            <path d="M 50 50 L 20 75 A 40 40 0 0 1 50 10 Z" fill="#7f8c8d" />
                                        </svg>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="detail-metric-footer">
                            <div class="list-title">Top Reject Reasons</div>
                            <div class="top-items-list" id="topScrapList">
                                <div class="top-item">
                                    <div class="top-item-label">1. Misalignment (Station 3)</div>
                                    <div class="top-item-value">32 units</div>
                                </div>
                                <div class="top-item">
                                    <div class="top-item-label">2. Component Failure (Station 1)</div>
                                    <div class="top-item-value">24 units</div>
                                </div>
                                <div class="top-item">
                                    <div class="top-item-label">3. Calibration Error (Station 4)</div>
                                    <div class="top-item-value">15 units</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Downtime -->
                    <div class="detail-metric-card">
                        <div class="detail-metric-header">Downtime Analysis</div>
                        <div class="toggle-container">
                            <button class="toggle-btn active" id="downtimeReasonBtn">By Reason</button>
                            <button class="toggle-btn" id="downtimeMachineBtn">By Machine</button>
                            <button class="toggle-btn" id="downtimeDurationBtn">By Duration</button>
                        </div>
                        <div class="chart-container" id="downtimeChart">
                            <!-- Bar chart will be rendered here by JS -->
                            <div class="chart-placeholder">
                                <div class="bar-container">
                                    <div class="chart-bar downtime-bar" style="height: 20%"></div>
                                    <div class="chart-bar downtime-bar" style="height: 40%"></div>
                                    <div class="chart-bar downtime-bar" style="height: 30%"></div>
                                    <div class="chart-bar downtime-bar high" style="height: 45%"></div>
                                    <div class="chart-bar downtime-bar" style="height: 25%"></div>
                                    <div class="chart-bar downtime-bar" style="height: 10%"></div>
                                    <div class="chart-bar downtime-bar medium" style="height: 35%"></div>
                                </div>
                                <div class="x-axis-labels">
                                    <span>Mar 18</span>
                                    <span>Mar 19</span>
                                    <span>Mar 20</span>
                                    <span>Mar 21</span>
                                    <span>Mar 22</span>
                                    <span>Mar 23</span>
                                    <span>Mar 24</span>
                                </div>
                            </div>
                        </div>
                        <div class="detail-metric-footer">
                            <div class="list-title">Top Downtime Reasons</div>
                            <div class="top-items-list" id="topDowntimeList">
                                <div class="top-item">
                                    <div class="top-item-label">1. Equipment Maintenance</div>
                                    <div class="top-item-value">R 4,200</div>
                                </div>
                                <div class="top-item">
                                    <div class="top-item-label">2. Material Changeover</div>
                                    <div class="top-item-value">R 2,850</div>
                                </div>
                                <div class="top-item">
                                    <div class="top-item-label">3. Quality Inspection</div>
                                    <div class="top-item-value">R 1,720</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /**
         * ======================================
         * CONFIGURATION
         * ======================================
         */
        
        // Main configuration object for the dashboard
        const CONFIG = {
            // URL to fetch operational data from
            dataUrl: 'OpsData.json',
            
            // Refresh interval in milliseconds (5 minutes)
            refreshInterval: 5 * 60 * 1000,
            
            // Default period for data display
            defaultPeriod: 'weekly', // Changed from 'daily' to 'weekly'
            
            // Default date range (last 5 production dates)
            defaultDateRange: {
                days: 7  // Changed from 5 to 7 days (one week)
            },
            
            // Debug mode to show the debug log
            debugMode: true,
            
            // Production lines that need special handling for Base Products
            specialLinesBaseProducts: {
                'nosi-scalpel': true,
                'mvokwe-3rd line': true
            },
            
            // Variant timeline colors
            timelineColors: {
                'default': 'var(--timeline-blue)',
                'XL': 'var(--timeline-orange)',
                'S10': 'var(--timeline-red)',
                'S20': 'var(--timeline-blue)',
                'Plus': 'var(--timeline-purple)',
                'Regular': 'var(--timeline-blue)',
                'Deluxe': 'var(--timeline-purple)',
                'Standard': 'var(--timeline-blue)'
            },
            
            // Thresholds for KPI color coding
            thresholds: {
                scheduleAttainment: {
                    good: 95,      // >= 95% = green
                    warning: 85    // >= 85% = yellow, < 85% = red
                },
                labourCostPerUnit: {
                    good: 300,     // <= 300 = green
                    warning: 400   // <= 400 = yellow, > 400 = red
                },
                scrapPercentage: {
                    good: 5,       // <= 5% = green
                    warning: 15    // <= 15% = yellow, > 15% = red
                },
                downtimeHours: {
                    good: 3,       // <= 3 hours = green
                    warning: 6     // <= 6 hours = yellow, > 6 hours = red
                }
            }
        };

        /**
         * ======================================
         * LOGGING UTILITIES
         * ======================================
         */
        
        /**
         * Debug logger for diagnostic information
         */
        const Logger = {
            logElement: null,
            
            /**
             * Initialize the logger
             */
            init: function() {
                this.logElement = document.getElementById('debugLog');
                if (CONFIG.debugMode) {
                    this.logElement.style.display = 'block';
                }
            },
            
            /**
             * Log an information message
             * @param {string} message - The message to log
             */
            info: function(message) {
                this._log(message, 'info');
            },
            
            /**
             * Log a warning message
             * @param {string} message - The message to log
             */
            warn: function(message) {
                this._log(message, 'warning');
            },
            
            /**
             * Log an error message
             * @param {string} message - The message to log
             * @param {Error} [error] - Optional error object
             */
            error: function(message, error) {
                let fullMessage = message;
                if (error) {
                    fullMessage += `: ${error.message}`;
                }
                this._log(fullMessage, 'error');
                if (error && error.stack) {
                    this._log(`Stack: ${error.stack}`, 'error');
                }
            },
            
            /**
             * Internal method to add a log entry
             * @param {string} message - The message to log
             * @param {string} level - The log level ('info', 'warning', 'error')
             * @private
             */
            _log: function(message, level) {
                if (!this.logElement) return;
                
                const timestamp = new Date().toISOString();
                const entry = document.createElement('div');
                entry.className = `debug-log-entry ${level}`;
                entry.textContent = `[${timestamp}] ${message}`;
                
                this.logElement.appendChild(entry);
                this.logElement.scrollTop = this.logElement.scrollHeight;
                
                // Also log to console
                switch(level) {
                    case 'info':
                        console.log(message);
                        break;
                    case 'warning':
                        console.warn(message);
                        break;
                    case 'error':
                        console.error(message);
                        break;
                }
            }
        };

        /**
         * ======================================
         * DATE UTILITIES
         * ======================================
         */
        
        // Store current date range
        let currentDateRange = {
            start: null,
            end: null
        };
        
        // Store current period type
        let currentPeriod = CONFIG.defaultPeriod;
        
        // Store week cycle preference (0-6, where 0 is Sunday, 1 is Monday, etc.)
        let weekCycleStartDay = 1; // Default to Monday

        /**
         * Gets the default date range based on week cycle preference
         * @returns {Object} Object with start and end dates
         */
        function getDefaultDateRange() {
            const now = new Date();
            
            // Get current day of week (0-6, where 0 is Sunday)
            const currentDay = now.getDay();
            
            // Calculate days to subtract to get to the start day
            const daysToSubtract = (currentDay - weekCycleStartDay + 7) % 7;
            
            // Calculate start date (the selected start day of the current/most recent week)
            const start = new Date(now);
            start.setDate(start.getDate() - daysToSubtract);
            start.setHours(0, 0, 0, 0);
            
            // Calculate end date (start + 6 days to complete the week)
            const end = new Date(start);
            end.setDate(end.getDate() + 6);
            end.setHours(23, 59, 59, 999);
            
            return {
                start: start.toISOString().split('T')[0],
                end: end.toISOString().split('T')[0]
            };
        }

        /**
         * Sets the date inputs to the current date range values
         */
        function setDateInputs() {
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            
            if (currentDateRange.start) {
                startDateInput.value = currentDateRange.start.split('T')[0];
            }
            
            if (currentDateRange.end) {
                endDateInput.value = currentDateRange.end.split('T')[0];
            }
        }
        
        /**
         * Navigates to the previous period
         */
        function navigateToPreviousPeriod() {
            Logger.info('Navigating to previous period: ' + currentPeriod);
            
            const start = new Date(currentDateRange.start);
            const end = new Date(currentDateRange.end);
            
            switch(currentPeriod) {
                case 'daily':
                    // Move back one day
                    start.setDate(start.getDate() - 1);
                    end.setDate(end.getDate() - 1);
                    break;
                case 'weekly':
                    // Move back one week
                    start.setDate(start.getDate() - 7);
                    end.setDate(end.getDate() - 7);
                    break;
                case 'monthly':
                    // Move back one month
                    start.setMonth(start.getMonth() - 1);
                    end.setMonth(end.getMonth() - 1);
                    break;
            }
            
            // Update date range
            currentDateRange.start = start.toISOString().split('T')[0];
            currentDateRange.end = end.toISOString().split('T')[0];
            
            // Reload dashboard
            initializeDashboard();
        }
        
        /**
         * Navigates to the next period
         */
        function navigateToNextPeriod() {
            Logger.info('Navigating to next period: ' + currentPeriod);
            
            const start = new Date(currentDateRange.start);
            const end = new Date(currentDateRange.end);
            
            switch(currentPeriod) {
                case 'daily':
                    // Move forward one day
                    start.setDate(start.getDate() + 1);
                    end.setDate(end.getDate() + 1);
                    break;
                case 'weekly':
                    // Move forward one week
                    start.setDate(start.getDate() + 7);
                    end.setDate(end.getDate() + 7);
                    break;
                case 'monthly':
                    // Move forward one month
                    start.setMonth(start.getMonth() + 1);
                    end.setMonth(end.getMonth() + 1);
                    break;
            }
            
            // Update date range
            currentDateRange.start = start.toISOString().split('T')[0];
            currentDateRange.end = end.toISOString().split('T')[0];
            
            // Reload dashboard
            initializeDashboard();
        }
        
        /**
         * Stores user preferences in localStorage
         */
        function storeUserPreferences() {
            try {
                const preferences = {
                    weekCycleStartDay: weekCycleStartDay,
                    period: currentPeriod
                };
                
                localStorage.setItem('dashboardPreferences', JSON.stringify(preferences));
                Logger.info('Stored user preferences: ' + JSON.stringify(preferences));
            } catch (error) {
                Logger.error('Error storing user preferences', error);
            }
        }
        
        /**
         * Loads user preferences from localStorage
         */
        function loadUserPreferences() {
            try {
                const preferencesString = localStorage.getItem('dashboardPreferences');
                
                if (preferencesString) {
                    const preferences = JSON.parse(preferencesString);
                    
                    // Set week cycle start day if defined
                    if (preferences.weekCycleStartDay !== undefined) {
                        weekCycleStartDay = preferences.weekCycleStartDay;
                        // Update dropdown
                        const cycleStartSelect = document.getElementById('cycleStartDay');
                        if (cycleStartSelect) {
                            cycleStartSelect.value = weekCycleStartDay.toString();
                        }
                    }
                    
                    // Set period if defined
                    if (preferences.period) {
                        currentPeriod = preferences.period;
                        // Update button text
                        const periodToggle = document.getElementById('periodToggle');
                        if (periodToggle) {
                            periodToggle.textContent = currentPeriod.charAt(0).toUpperCase() + currentPeriod.slice(1);
                        }
                    }
                    
                    Logger.info('Loaded user preferences: ' + JSON.stringify(preferences));
                }
            } catch (error) {
                Logger.error('Error loading user preferences', error);
            }
        }

        /**
         * ======================================
         * EVENT HANDLERS
         * ======================================
         */

        /**
         * Handles period toggle button click
         * @param {Event} e - The click event
         */
        function handlePeriodToggle(e) {
            const btn = e.target;
            // Toggle between Weekly/Monthly/Daily
            if (btn.textContent === 'Weekly') {
                btn.textContent = 'Monthly';
                currentPeriod = 'monthly';
                Logger.info('Switched to Monthly view');
            } else if (btn.textContent === 'Monthly') {
                btn.textContent = 'Daily';
                currentPeriod = 'daily';
                Logger.info('Switched to Daily view');
            } else {
                btn.textContent = 'Weekly';
                currentPeriod = 'weekly';
                Logger.info('Switched to Weekly view');
            }
            
            // Store the user preference
            storeUserPreferences();
            
            // Reload dashboard with new period setting
            initializeDashboard();
        }

        /**
         * Handles refresh button click
         */
        function handleRefresh() {
            Logger.info('Manual refresh requested');
            initializeDashboard();
        }

        /**
         * Handles date range button click
         */
        function handleDateRangeButton() {
            Logger.info('Date range button clicked');
            const dropdown = document.getElementById('datePickerDropdown');
            dropdown.classList.toggle('show');
            
            // Set date inputs to current values
            setDateInputs();
        }

        /**
         * Handles apply date range button click
         */
        function handleApplyDateRange() {
            Logger.info('Apply date range button clicked');
            
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            
            // Validate inputs
            if (!startDateInput.value || !endDateInput.value) {
                Logger.warn('Invalid date range inputs');
                return;
            }
            
            const startDate = new Date(startDateInput.value);
            const endDate = new Date(endDateInput.value);
            
            // Validate date range
            if (startDate > endDate) {
                Logger.warn('Start date cannot be after end date');
                alert('Start date cannot be after end date');
                return;
            }
            
            // Update current date range
            currentDateRange.start = startDateInput.value;
            currentDateRange.end = endDateInput.value;
            
            // Hide dropdown
            document.getElementById('datePickerDropdown').classList.remove('show');
            
            // Reload dashboard with new date range
            initializeDashboard();
        }

        /**
         * Handles 'Apply & Remember' button click
         */
        function handleApplyAndRememberCycle() {
            Logger.info('Apply and remember cycle button clicked');
            
            // Get selected cycle
            const cycleStartSelect = document.getElementById('cycleStartDay');
            const selectedCycle = parseInt(cycleStartSelect.value);
            
            // Update cycle preference
            weekCycleStartDay = selectedCycle;
            
            // Store preference in localStorage
            storeUserPreferences();
            
            // Apply date range
            handleApplyDateRange();
        }

        /**
         * Handles document click to close date picker dropdown
         * @param {Event} e - The click event
         */
        function handleDocumentClick(e) {
            const dropdown = document.getElementById('datePickerDropdown');
            const dateRangeButton = document.getElementById('dateRangeButton');
            
            // Close dropdown if click is outside the dropdown and button
            if (dropdown.classList.contains('show') && 
                !dropdown.contains(e.target) && 
                e.target !== dateRangeButton) {
                dropdown.classList.remove('show');
            }
        }

        /**
         * ======================================
         * DATA FETCHING
         * ======================================
         */

        /**
         * Fetches operational data from the specified URL
         * @returns {Promise<Object>} The parsed operational data
         */
        async function fetchOpsData() {
            Logger.info(`Fetching operational data from: ${CONFIG.dataUrl}`);
            
            try {
                const response = await fetch(CONFIG.dataUrl);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                
                const data = await response.json();
                Logger.info('Operational data fetched successfully');
                
                return data;
            } catch (error) {
                Logger.error('Error fetching operational data', error);
                throw error;
            }
        }

        /**
         * ======================================
         * DATA TRANSFORMATION
         * ======================================
         */

        /**
         * Filters operational data based on selected date range
         * @param {Object} opsData - The raw operational data
         * @param {string} startDate - Start date in ISO format
         * @param {string} endDate - End date in ISO format
         * @returns {Array} Filtered production data records
         */
        function filterDataByDateRange(opsData, startDate, endDate) {
            Logger.info(`Filtering data from ${startDate} to ${endDate}`);
            
            if (!opsData || !opsData.productionData || !Array.isArray(opsData.productionData)) {
                Logger.warn('No production data available to filter');
                return [];
            }
            
            const start = new Date(startDate);
            const end = new Date(endDate);
            end.setHours(23, 59, 59, 999); // Include the entire end day
            
            return opsData.productionData.filter(record => {
                const recordDate = new Date(record.Date);
                return recordDate >= start && recordDate <= end;
            });
        }

        /**
         * Gets the last N production dates from the data
         * @param {Object} opsData - The raw operational data
         * @param {number} n - Number of dates to get
         * @returns {Object} Object with start and end dates
         */
        function getLastNProductionDates(opsData, n) {
            if (!opsData || !opsData.productionData || !Array.isArray(opsData.productionData)) {
                Logger.warn('No production data available to get dates');
                return getDefaultDateRange();
            }
            
            // Sort dates in descending order
            const sortedDates = [...opsData.productionData]
                .map(record => record.Date)
                .sort((a, b) => new Date(b) - new Date(a));
            
            // Remove duplicates
            const uniqueDates = [...new Set(sortedDates)];
            
            if (uniqueDates.length === 0) {
                Logger.warn('No dates found in production data');
                return getDefaultDateRange();
            }
            
            // Get the latest N dates
            const latestDates = uniqueDates.slice(0, n);
            
            const end = latestDates[0];
            const start = latestDates[latestDates.length - 1];
            
            Logger.info(`Got last ${n} production dates: ${start} to ${end}`);
            
            return {
                start,
                end
            };
        }

        /**
         * Transforms operational data to the format expected by the dashboard
         * @param {Object} opsData - The raw operational data
         * @param {Array} filteredData - The filtered production data records
         * @returns {Object} Transformed data ready for UI rendering
         */
        function transformOpsData(opsData, filteredData) {
            Logger.info(`Transforming operational data, lastUpdated: ${opsData.lastUpdated}`);
            
            // Group data by production line and base product for special cases
            const lineGroups = groupDataByProductionLineAndBaseProduct(filteredData);
            
            // Calculate plant-wide metrics
            const plantWideMetrics = calculatePlantWideMetrics(filteredData);
            
            // Get date range for display
            const dateRange = {
                start: currentDateRange.start,
                end: currentDateRange.end
            };
            
            // Transform production lines data
            const productionLines = transformProductionLines(lineGroups);
            
            // Build the final transformed data structure
            const transformedData = {
                lastUpdated: opsData.lastUpdated,
                dateRange: dateRange,
                plantWideMetrics: plantWideMetrics,
                lines: productionLines,
                thresholds: CONFIG.thresholds
            };
            
            Logger.info(`Transformed ${transformedData.lines.length} production lines`);
            return transformedData;
        }

        /**
         * Groups filtered data by production line and base product for special cases
         * @param {Array} filteredData - The filtered production data records
         * @returns {Object} Data grouped by production line ID and base product
         */
        function groupDataByProductionLineAndBaseProduct(filteredData) {
            if (!filteredData || filteredData.length === 0) {
                Logger.warn('No filtered data available to group');
                return {};
            }
            
            const lineGroups = {};
            
            filteredData.forEach(record => {
                const lineId = record['Production Line ID'];
                
                if (!lineId) {
                    Logger.warn(`Record missing Production Line ID: ${JSON.stringify(record)}`);
                    return;
                }
                
                // For special lines, also include the base product in the key
                let groupKey = lineId;
                
                // Check if this is a special line that needs base product separation
                if (CONFIG.specialLinesBaseProducts[lineId] && record['Base Product']) {
                    groupKey = `${lineId}-${record['Base Product']}`;
                }
                
                if (!lineGroups[groupKey]) {
                    lineGroups[groupKey] = {
                        id: lineId,
                        name: record['Production Line Name'],
                        color: record['Production Line Color'],
                        type: record['Production Line Type'],
                        baseProduct: record['Base Product'] || null,
                        records: []
                    };
                }
                
                lineGroups[groupKey].records.push(record);
            });
            
            Logger.info(`Grouped data into ${Object.keys(lineGroups).length} production lines`);
            return lineGroups;
        }

        /**
         * Calculates plant-wide metrics from filtered data
         * @param {Array} filteredData - The filtered production data records
         * @returns {Object} Calculated plant-wide metrics
         */
        function calculatePlantWideMetrics(filteredData) {
            if (!filteredData || filteredData.length === 0) {
                Logger.warn('No filtered data available to calculate plant-wide metrics');
                return null;
            }
            
            // Initialize metrics
            let totalScheduleAttainment = 0;
            let totalStaffCost = 0;
            let totalUnits = 0;
            let totalScrapPercentage = 0;
            let totalDowntime = 0;
            let recordCount = 0;
            
            // Previous period metrics for trend calculation
            let prevTotalScheduleAttainment = 0;
            let prevTotalStaffCost = 0;
            let prevTotalUnits = 0;
            let prevTotalScrapPercentage = 0;
            let prevTotalDowntime = 0;
            let prevRecordCount = 0;
            
            // Sort records by date
            const sortedRecords = [...filteredData].sort((a, b) => 
                new Date(a.Date) - new Date(b.Date)
            );
            
            // Determine mid-point for trend calculation
            const midPoint = Math.floor(sortedRecords.length / 2);
            
            sortedRecords.forEach((record, index) => {
                // Skip records with missing data
                if (record['Schedule Attainment'] === undefined || 
                    record['Staff Cost'] === undefined ||
                    record['Actual Devices Produced'] === undefined ||
                    record['Scrap Cost as % of Production Value'] === undefined) {
                    return;
                }
                
                // For the first half of records (previous period)
                if (index < midPoint) {
                    prevTotalScheduleAttainment += parseFloat(record['Schedule Attainment'] || 0);
                    
                    // Ensure Staff Cost is correctly parsed - always convert to number
                    const staffCost = parseFloat(record['Staff Cost']);
                    prevTotalStaffCost += !isNaN(staffCost) ? staffCost : 0;
                    
                    prevTotalUnits += parseInt(record['Actual Devices Produced'] || 0);
                    prevTotalScrapPercentage += parseFloat(record['Scrap Cost as % of Production Value'] || 0);
                    prevTotalDowntime += parseFloat(record['Downtime Duration (min)'] || 0);
                    prevRecordCount++;
                } 
                // For the second half of records (current period)
                else {
                    totalScheduleAttainment += parseFloat(record['Schedule Attainment'] || 0);
                    
                    // Ensure Staff Cost is correctly parsed - always convert to number
                    const staffCost = parseFloat(record['Staff Cost']);
                    totalStaffCost += !isNaN(staffCost) ? staffCost : 0;
                    
                    totalUnits += parseInt(record['Actual Devices Produced'] || 0);
                    totalScrapPercentage += parseFloat(record['Scrap Cost as % of Production Value'] || 0);
                    totalDowntime += parseFloat(record['Downtime Duration (min)'] || 0);
                    recordCount++;
                    
                    // Debug log to see values
                    Logger.info(`Record ${record.Date}: staffCost: ${staffCost}, totalStaffCost now: ${totalStaffCost}, units: ${record['Actual Devices Produced']}`);
                }
            });
            
            // Calculate current averages
            const avgScheduleAttainment = recordCount > 0 ? totalScheduleAttainment / recordCount : 0;
            const avgLabourCost = (totalUnits > 0) ? (totalStaffCost / recordCount) : 0;
            const avgScrapPercentage = recordCount > 0 ? totalScrapPercentage / recordCount : 0;
            // Convert downtime from minutes to hours
            const downtimeHours = totalDowntime / 60;
            
            // Calculate previous period averages
            const prevAvgScheduleAttainment = prevRecordCount > 0 ? prevTotalScheduleAttainment / prevRecordCount : 0;
            const prevAvgLabourCost = (prevTotalUnits > 0) ? (prevTotalStaffCost / prevRecordCount) : 0;
            const prevAvgScrapPercentage = prevRecordCount > 0 ? prevTotalScrapPercentage / prevRecordCount : 0;
            
            // Calculate trends (percentage change)
            const scheduleAttainmentTrend = prevAvgScheduleAttainment > 0 ? 
                ((avgScheduleAttainment - prevAvgScheduleAttainment) / prevAvgScheduleAttainment) * 100 : 0;
            const labourCostTrend = prevAvgLabourCost > 0 ? 
                ((avgLabourCost - prevAvgLabourCost) / prevAvgLabourCost) * 100 : 0;
            const scrapPercentageTrend = prevAvgScrapPercentage > 0 ? 
                ((avgScrapPercentage - prevAvgScrapPercentage) / prevAvgScrapPercentage) * 100 : 0;
            
            // Count downtime events
            const downtimeEvents = sortedRecords.filter(record => 
                (parseFloat(record['Downtime Duration (min)'] || 0)) > 0
            ).length;
            
            // Calculate downtime events trend (not percentage)
            const prevDowntimeEvents = prevRecordCount > 0 ? 
                Math.round(downtimeEvents * (prevRecordCount / recordCount)) : 0;
            const downtimeEventsTrend = downtimeEvents - prevDowntimeEvents;
            
            Logger.info(`Calculated plant-wide metrics: SA=${avgScheduleAttainment.toFixed(2)}, LC=${avgLabourCost.toFixed(2)} (from ${totalStaffCost}/${totalUnits}), SC=${avgScrapPercentage.toFixed(2)}, DE=${downtimeEvents}`);
            
            // Return structured metrics object
            return {
                scheduleAttainment: {
                    value: Math.round(avgScheduleAttainment * 10) / 10,  // Round to 1 decimal place
                    trend: Math.round(Math.abs(scheduleAttainmentTrend) * 10) / 10,  // Round to 1 decimal place,
                    trendDirection: scheduleAttainmentTrend >= 0 ? 'up' : 'down'
                },
                labourCostPerUnit: {
                    value: Math.round(avgLabourCost),  // Round to whole number
                    trend: Math.round(Math.abs(labourCostTrend) * 10) / 10,  // Round to 1 decimal place
                    trendDirection: labourCostTrend >= 0 ? 'up' : 'down'
                },
                scrapPercentage: {
                    value: Math.round(avgScrapPercentage * 10) / 10,  // Round to 1 decimal place
                    trend: Math.round(Math.abs(scrapPercentageTrend) * 10) / 10,  // Round to 1 decimal place
                    trendDirection: scrapPercentageTrend >= 0 ? 'up' : 'down'
                },
                downtimeEvents: {
                    value: downtimeEvents,
                    trend: Math.abs(downtimeEventsTrend),
                    trendDirection: downtimeEventsTrend >= 0 ? 'up' : 'down'
                }
            };
        }

        /**
         * Track current detail view state
         */
        const detailViewState = {
            lineId: null,
            dateRange: {
                start: null,
                end: null
            },
            scrapView: 'qty',         // 'qty' or 'cost'
            downtimeView: 'reason',   // 'reason', 'machine', or 'duration'
            costView: 'labour',       // 'labour' or 'unit'
            filteredData: null        // Store filtered data for reuse
        };

        function ensureDetailViewElementsExist() {
    const modal = document.getElementById('detailModal');
    
    // Check for and create scrap chart container
    let scrapChart = document.getElementById('scrapPercentageChart');
    if (!scrapChart) {
        Logger.warn("scrapPercentageChart container not found, creating it");
        const scrapCard = modal.querySelector('.detail-metric-card:nth-child(3)');
        if (scrapCard) {
            const chartContainer = scrapCard.querySelector('.chart-container');
            if (chartContainer) {
                chartContainer.id = 'scrapPercentageChart';
                chartContainer.style.height = '100px'; // Explicit height
            }
        }
    }
    
    // Check for and create reject pie chart container
    let rejectPie = document.getElementById('rejectPieChart');
    if (!rejectPie) {
        Logger.warn("rejectPieChart container not found, creating it");
        const scrapCard = modal.querySelector('.detail-metric-card:nth-child(3)');
        if (scrapCard) {
            const pieContainer = scrapCard.querySelector('.pie-chart-container');
            if (pieContainer) {
                // Create with ID if not exists
                if (!pieContainer.id) {
                    pieContainer.id = 'rejectPieChart';
                    pieContainer.style.height = '150px'; // Explicit height
                }
            }
        }
    }
    
    // Check for and create downtime chart container
    let downtimeChart = document.getElementById('downtimeChart');
    if (!downtimeChart) {
        Logger.warn("downtimeChart container not found, creating it");
        const downtimeCard = modal.querySelector('.detail-metric-card:nth-child(4)');
        if (downtimeCard) {
            const chartContainer = downtimeCard.querySelector('.chart-container');
            if (chartContainer) {
                chartContainer.id = 'downtimeChart';
                chartContainer.style.height = '100px'; // Explicit height
            }
        }
    }
    
    // Check if topScrapList exists
    let topScrapList = document.getElementById('topScrapList');
    if (!topScrapList) {
        Logger.warn("Creating missing 'topScrapList' element");
        const scrapFooter = modal.querySelector('.detail-metric-card:nth-child(3) .detail-metric-footer');
        if (scrapFooter) {
            scrapFooter.innerHTML = `
                <div class="list-title">Top Reject Reasons</div>
                <div class="top-items-list" id="topScrapList" style="max-height: 120px; overflow-y: auto;"></div>
            `;
        }
    }
    
    // Check if topDowntimeList exists
    let topDowntimeList = document.getElementById('topDowntimeList');
    if (!topDowntimeList) {
        Logger.warn("Creating missing 'topDowntimeList' element");
        const downtimeFooter = modal.querySelector('.detail-metric-card:nth-child(4) .detail-metric-footer');
        if (downtimeFooter) {
            downtimeFooter.innerHTML = `
                <div class="list-title">Top Downtime Reasons</div>
                <div class="top-items-list" id="topDowntimeList" style="max-height: 120px; overflow-y: auto;"></div>
            `;
        }
    }
}
        
// Fix 7: Enhance showDetailView to ensure elements exist
function showDetailView(lineId) {
    console.log("Original lineId:", lineId);
    const processedLineId = processLineId(lineId);
    console.log("Processed lineId:", processedLineId);
    
    // Store the current line ID
    detailViewState.lineId = processedLineId;
    
    // Use the date range from the main page
    detailViewState.dateRange.start = currentDateRange.start;
    detailViewState.dateRange.end = currentDateRange.end;
    
    // Update modal title
    const lineElement = document.querySelector(`[data-line-id="${lineId}"]`);
    if (lineElement) {
        const headerElement = lineElement.querySelector('.card-title');
        if (headerElement) {
            document.getElementById('modalTitle').textContent = headerElement.textContent + ' Details';
        } else {
            // Fallback if card-title is not found
            const supervisor = extractSupervisorName(processedLineId);
            let productName = '';
            
            // Try to determine product from line ID
            if (processedLineId.includes('scd')) {
                productName = 'SCD';
            } else if (processedLineId.includes('sum')) {
                productName = 'SUM';
            } else if (processedLineId.includes('levo')) {
                productName = 'LEVO';
            } else if (processedLineId.includes('popup')) {
                productName = 'PopUp';
            } else if (processedLineId.includes('scalpel')) {
                productName = 'Scalpel';
            } else {
                productName = 'Production Line';
            }
            
            document.getElementById('modalTitle').textContent = `${productName}: ${supervisor} Details`;
        }
    }
    
    // Update date range display
    updateModalDateRange();
    
    // Make sure the detail view elements exist before loading data
    ensureDetailViewElementsExist();
    
    // Load and render the charts
    loadDetailViewData();
    
    // Show the modal
    document.getElementById('detailModal').classList.add('show');
}

        /**
         * Processes the line ID to handle special cases
         * @param {string} lineId - The original line ID
         * @returns {string} The processed line ID
         */
        function processLineId(lineId) {
            // Look for card data attributes to get more accurate information
            const lineCard = document.querySelector(`[data-line-id="${lineId}"]`);
            if (!lineCard) return lineId;
            
            // Check for Scalpel cases
            if (lineId === 'nosi-scalpel') {
                // Check if card title contains "Packaging" explicitly
                const cardTitle = lineCard.querySelector('.card-title');
                if (cardTitle && cardTitle.textContent.toLowerCase().includes('packaging')) {
                    return 'nosi-scalpel-packaging';
                } else if (cardTitle && cardTitle.textContent.toLowerCase().includes('assembly')) {
                    return 'nosi-scalpel-assembly';
                }
                
                // Fallback to checking variant info if available
                const variantInfo = lineCard.querySelector('.variant-label');
                if (variantInfo && variantInfo.textContent.toLowerCase().includes('packaging')) {
                    return 'nosi-scalpel-packaging';
                } else {
                    return 'nosi-scalpel-assembly';
                }
            }
            
            // Check for 3rd line cases
            if (lineId === 'mvokwe-3rd line' || lineId === 'mvokwe-3rd-line') {
                // Check card title explicitly for UBT or SCD
                const cardTitle = lineCard.querySelector('.card-title');
                if (cardTitle) {
                    if (cardTitle.textContent.toLowerCase().includes('ubt')) {
                        return 'mvokwe-3rd-line-ubt';
                    } else if (cardTitle.textContent.toLowerCase().includes('scd')) {
                        return 'mvokwe-3rd-line-scd';
                    }
                }
                
                // Check variant info if title check fails
                const variantInfo = lineCard.querySelector('.variant-info');
                if (variantInfo) {
                    const variantText = variantInfo.textContent.toLowerCase();
                    if (variantText.includes('ubt')) {
                        return 'mvokwe-3rd-line-ubt';
                    } else if (variantText.includes('scd')) {
                        return 'mvokwe-3rd-line-scd';
                    }
                }
                
                // Check base product if both checks fail
                const baseProductElement = lineCard.querySelector('.base-product');
                if (baseProductElement) {
                    const baseProduct = baseProductElement.textContent.trim();
                    if (baseProduct === 'UBT') {
                        return 'mvokwe-3rd-line-ubt';
                    } else if (baseProduct === 'SCD') {
                        return 'mvokwe-3rd-line-scd';
                    }
                }
            }
            
            return lineId;
        }

        /**
         * Extracts the supervisor name from the production line ID
         * @param {string} lineId - The production line ID (e.g., "mvokwe-3rd line")
         * @returns {string} The capitalized supervisor name
         */
        function extractSupervisorName(lineId) {
            if (!lineId) return '';
            
            // Split by hyphen and take the first part
            const parts = lineId.split('-');
            if (parts.length < 1) return '';
            
            // Capitalize the first letter
            const supervisor = parts[0];
            return supervisor.charAt(0).toUpperCase() + supervisor.slice(1);
        }

        /**
         * Hides the detail view
         */
        function hideDetailView() {
            Logger.info('Hiding detail view');
            document.getElementById('detailModal').classList.remove('show');
        }

        /**
         * Updates the date range display in the modal
         */
        function updateModalDateRange() {
            const start = new Date(detailViewState.dateRange.start);
            const end = new Date(detailViewState.dateRange.end);
            
            // Format dates
            const options = { month: 'short', day: 'numeric', year: 'numeric' };
            const startFormatted = start.toLocaleDateString('en-US', options);
            const endFormatted = end.toLocaleDateString('en-US', options);
            
            // Update the display
            document.getElementById('modalDateRange').textContent = `${startFormatted} - ${endFormatted}`;
        }

        /**
         * Navigates to the previous week
         */
        function navigateToPreviousWeek() {
            Logger.info('Navigating to previous week');
            
            const start = new Date(detailViewState.dateRange.start);
            const end = new Date(detailViewState.dateRange.end);
            
            // Move both dates back by 7 days
            start.setDate(start.getDate() - 7);
            end.setDate(end.getDate() - 7);
            
            // Update both the detail view state and the main page state
            detailViewState.dateRange.start = start.toISOString().split('T')[0];
            detailViewState.dateRange.end = end.toISOString().split('T')[0];
            
            // Also update the main date range
            currentDateRange.start = detailViewState.dateRange.start;
            currentDateRange.end = detailViewState.dateRange.end;
            
            // Update displays and reload data
            updateModalDateRange();
            updateDateRangeDisplay(currentDateRange);
            loadDetailViewData();
        }

        /**
         * Navigates to the next week
         */
        function navigateToNextWeek() {
            Logger.info('Navigating to next week');
            
            const start = new Date(detailViewState.dateRange.start);
            const end = new Date(detailViewState.dateRange.end);
            
            // Move both dates forward by 7 days
            start.setDate(start.getDate() + 7);
            end.setDate(end.getDate() + 7);
            
            // Update both the detail view state and the main page state
            detailViewState.dateRange.start = start.toISOString().split('T')[0];
            detailViewState.dateRange.end = end.toISOString().split('T')[0];
            
            // Also update the main date range
            currentDateRange.start = detailViewState.dateRange.start;
            currentDateRange.end = detailViewState.dateRange.end;
            
            // Update displays and reload data
            updateModalDateRange();
            updateDateRangeDisplay(currentDateRange);
            loadDetailViewData();
        }

        /**
         * Toggles the cost view
         * @param {string} view - The view to switch to ('labour' or 'unit')
         */
        function toggleCostView(view) {
            Logger.info(`Toggling cost view to: ${view}`);
            
            // Update the state
            detailViewState.costView = view;
            
            // Update button active states
            document.getElementById('labourCostBtn').classList.toggle('active', view === 'labour');
            document.getElementById('unitCostBtn').classList.toggle('active', view === 'unit');
            
            // Update the chart with the stored filtered data
            if (detailViewState.filteredData) {
                renderLabourCostChart(detailViewState.filteredData);
            }
        }

        /**
         * Toggles the scrap view between quantity and cost
         * @param {string} view - The view to switch to ('qty' or 'cost')
         */
        function toggleScrapView(view) {
            Logger.info(`Toggling scrap view to: ${view}`);
            
            // Update the state
            detailViewState.scrapView = view;
            
            // Update button active states
            document.getElementById('scrapQtyBtn').classList.toggle('active', view === 'qty');
            document.getElementById('scrapCostBtn').classList.toggle('active', view === 'cost');
            
            // Update the display using the stored filtered data
            if (detailViewState.filteredData) {
                updateTopScrapList(detailViewState.filteredData);
            }
        }
        /**
         * Toggles the downtime view
         * @param {string} view - The view to switch to ('reason', 'machine', or 'duration')
         */
        function toggleDowntimeView(view) {
            Logger.info(`Toggling downtime view to: ${view}`);
            
            // Update the state
            detailViewState.downtimeView = view;
            
            // Update button active states
            document.getElementById('downtimeReasonBtn').classList.toggle('active', view === 'reason');
            document.getElementById('downtimeMachineBtn').classList.toggle('active', view === 'machine');
            document.getElementById('downtimeDurationBtn').classList.toggle('active', view === 'duration');
            
            // Update the display using the stored filtered data
            if (detailViewState.filteredData) {
                updateTopDowntimeList(detailViewState.filteredData);
            }
        }

        function loadDetailViewData() {
    Logger.info(`Loading detail view data for line: ${detailViewState.lineId}`);
    
    // First ensure all DOM elements exist
    ensureDetailViewElementsExist();
    
    // Get the filtered data for the line and date range
    const filteredData = getFilteredLineData(detailViewState.lineId, detailViewState.dateRange.start, detailViewState.dateRange.end);
    
    Logger.info(`Retrieved ${filteredData.length} records for line ${detailViewState.lineId}`);
    
    // Store the filtered data for reuse
    detailViewState.filteredData = filteredData;
    
    if (filteredData.length === 0) {
        Logger.warn(`No data available for line ${detailViewState.lineId} in selected date range`);
        showNoDataMessage();
        return;
    }
    
    // Log a sample record to debug field names
    if (filteredData.length > 0) {
        const sample = filteredData[0];
        Logger.info(`Sample record fields: ${Object.keys(sample).join(', ')}`);
        
        // Log sample scrap and downtime fields to debug
        if (sample['Top Rejects by QTY (Reason - Station - QTY - Cost)']) {
            Logger.info(`Sample reject data: ${sample['Top Rejects by QTY (Reason - Station - QTY - Cost)']}`);
        }
        
        if (sample['Top Downtime by Cost (Reason - Machine - Cost - Downtime Min)']) {
            Logger.info(`Sample downtime data: ${sample['Top Downtime by Cost (Reason - Machine - Cost - Downtime Min)']}`);
        }
    }
    
    try {
        // Render charts with actual data
        renderScheduleAttainmentChart(filteredData);
        renderLabourCostChart(filteredData);
        renderScrapPercentageChart(filteredData);
        renderDowntimeChart(filteredData);
        renderRejectPieChart(filteredData);
        
        // Update lists with actual data
        updateTopScrapList(filteredData);
        updateTopDowntimeList(filteredData);
    } catch (error) {
        Logger.error(`Error rendering charts: ${error.message}`, error);
        showNoDataMessage();
    }
}

        /**
         * Gets filtered data for a specific line and date range
         * @param {string} lineId - The ID of the line
         * @param {string} startDate - Start date in ISO format
         * @param {string} endDate - End date in ISO format
         * @returns {Array} Filtered production data records
         */
        function getFilteredLineData(lineId, startDate, endDate) {
            // Check if we have data available
            if (!window.dashboardData || !window.dashboardData.productionData) {
                Logger.warn('No production data available');
                return [];
            }
            
            const start = new Date(startDate);
            start.setHours(0, 0, 0, 0); // Set to beginning of day to include all start date data
            
            const end = new Date(endDate);
            end.setHours(23, 59, 59, 999); // Include the entire end day
            
            // Filter by line ID and date range
            return window.dashboardData.productionData.filter(record => {
                const recordDate = new Date(record.Date);
                
                // Proper comparison ensuring start date is included
                const isInDateRange = recordDate >= start && recordDate <= end;
                
                // Mapping for special cases
                let matchesLineId = record['Production Line ID'] === lineId;
                
                // Special case for Scalpel packaging vs assembly
                if (lineId === 'nosi-scalpel-packaging' && record['Production Line ID'] === 'nosi-scalpel') {
                    matchesLineId = record.Variant && record.Variant.toLowerCase().includes('packaging');
                } 
                else if (lineId === 'nosi-scalpel-assembly' && record['Production Line ID'] === 'nosi-scalpel') {
                    matchesLineId = !record.Variant || !record.Variant.toLowerCase().includes('packaging');
                }
                // Special case for 3rd line UBT vs SCD
                else if (lineId === 'mvokwe-3rd-line-ubt' && record['Production Line ID'] === 'mvokwe-3rd line') {
                    matchesLineId = record['Base Product'] === 'UBT';
                }
                else if (lineId === 'mvokwe-3rd-line-scd' && record['Production Line ID'] === 'mvokwe-3rd line') {
                    matchesLineId = record['Base Product'] === 'SCD';
                }
                
                return matchesLineId && isInDateRange;
            });
        }

        /**
         * Shows a message when no data is available
         */
        function showNoDataMessage() {
            const noDataMessage = '<div style="text-align: center; padding: 20px; color: var(--text-light);">No data available for the selected period.</div>';
            
            document.getElementById('scheduleAttainmentChart').innerHTML = noDataMessage;
            document.getElementById('labourCostChart').innerHTML = noDataMessage;
            document.getElementById('scrapPercentageChart').innerHTML = noDataMessage;
            document.getElementById('downtimeChart').innerHTML = noDataMessage;
            document.getElementById('rejectPieChart').innerHTML = noDataMessage;
            
            document.getElementById('topScrapList').innerHTML = noDataMessage;
            document.getElementById('topDowntimeList').innerHTML = noDataMessage;
        }

        /**
         * ======================================
         * UI RENDERING
         * ======================================
         */

        /**
         * Renders the entire dashboard with the provided data
         * @param {Object} data - The transformed dashboard data
         */
        function renderDashboard(data) {
            Logger.info('Rendering dashboard with transformed data');
            
            // Update date range display
            updateDateRangeDisplay(data.dateRange);
            
            // Render KPI summary
            renderKpiSummary(data.plantWideMetrics);
            
            // Clear the dashboard grid
            const dashboardGrid = document.getElementById('dashboardGrid');
            dashboardGrid.innerHTML = '';
            
            // Create a position map for the grid cells
            const positionMap = {
                '1-1': null, // Row 1, Column 1 (SCD)
                '1-2': null, // Row 1, Column 2 (LEVO)
                '1-3': null, // Row 1, Column 3 (Scalpel Assembly)
                '1-4': null, // Row 1, Column 4 (3rd Line UBT)
                '2-1': null, // Row 2, Column 1 (SUM)
                '2-2': null, // Row 2, Column 2 (PopUp)
                '2-3': null, // Row 2, Column 3 (Scalpel Packaging)
                '2-4': null  // Row 2, Column 4 (3rd Line SCD)
            };
            
            // Assign the lines to their positions
            data.lines.forEach(line => {
                // Skip lines without position information
                if (!line.row || !line.col) return;
                
                const positionKey = `${line.row}-${line.col}`;
                positionMap[positionKey] = line;
                Logger.info(`Assigned ${line.name} to position ${positionKey}`);
            });
            
            // Create and render the line cards in the grid
            for (const [positionKey, line] of Object.entries(positionMap)) {
                if (!line) continue;
                
                // Create a new grid cell div
                const gridCell = document.createElement('div');
                gridCell.className = `grid-position-${positionKey}`;
                
                // Render the appropriate card type
                if (line.isPopUpLine) {
                    gridCell.innerHTML = renderPopUpLineCard(line);
                } else {
                    gridCell.innerHTML = renderLineCard(line);
                }
                
                // Add the grid cell to the dashboard
                dashboardGrid.appendChild(gridCell);
            }
        }

        /**
         * Updates the date range display
         * @param {Object} dateRange - The date range to display
         */
        function updateDateRangeDisplay(dateRange) {
            if (!dateRange) {
                Logger.warn('No date range provided');
                return;
            }
            
            const dateRangeElement = document.getElementById('dateRangeDisplay');
            const formattedDateRange = formatDateRange(dateRange.start, dateRange.end);
            dateRangeElement.textContent = `Period: ${formattedDateRange}`;
            Logger.info(`Updated date range display: ${formattedDateRange}`);
        }

        /**
         * Formats a date range for display
         * @param {string} startDate - Start date in ISO format
         * @param {string} endDate - End date in ISO format
         * @returns {string} Formatted date range
         */
        function formatDateRange(startDate, endDate) {
            try {
                const start = new Date(startDate);
                const end = new Date(endDate);
                
                // Format to MMM d-d, yyyy pattern
                const startMonth = start.toLocaleString('default', { month: 'short' });
                const endMonth = end.toLocaleString('default', { month: 'short' });
                const startDay = start.getDate();
                const endDay = end.getDate();
                const year = end.getFullYear();
                
                if (startMonth === endMonth) {
                    return `${startMonth} ${startDay}-${endDay}, ${year}`;
                } else {
                    return `${startMonth} ${startDay} - ${endMonth} ${endDay}, ${year}`;
                }
            } catch (error) {
                Logger.error('Error formatting date range', error);
                return `${startDate} to ${endDate}`;
            }
        }

        /**
         * Renders the KPI summary section
         * @param {Object} metrics - The plant-wide metrics
         */
        function renderKpiSummary(metrics) {
            if (!metrics) {
                Logger.error('No plant-wide metrics available for rendering');
                showKpiSummaryError();
                return;
            }
            
            const kpiSummaryElement = document.getElementById('kpiSummary');
            
            Logger.info('Rendering KPI summary');
            kpiSummaryElement.innerHTML = `
                <div class="kpi-card">
                    <div class="kpi-title">Schedule Attainment</div>
                    <div class="kpi-value">
                        <div class="kpi-value-number">${metrics.scheduleAttainment.value}%</div>
                        <div class="kpi-trend ${metrics.scheduleAttainment.trendDirection === 'up' ? 'trend-up' : 'trend-down'}">
                            ${metrics.scheduleAttainment.trendDirection === 'up' ? '' : ''} ${Math.abs(metrics.scheduleAttainment.trend)}%
                        </div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-title">Labour Cost per Unit</div>
                    <div class="kpi-value">
                        <div class="kpi-value-number">R${metrics.labourCostPerUnit.value}</div>
                        <div class="kpi-trend ${metrics.labourCostPerUnit.trendDirection === 'down' ? 'trend-up' : 'trend-down'}">
                            ${metrics.labourCostPerUnit.trendDirection === 'up' ? '' : ''} ${Math.abs(metrics.labourCostPerUnit.trend)}%
                        </div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-title">Scrap Percentage</div>
                    <div class="kpi-value">
                        <div class="kpi-value-number">${metrics.scrapPercentage.value}%</div>
                        <div class="kpi-trend ${metrics.scrapPercentage.trendDirection === 'down' ? 'trend-up' : 'trend-down'}">
                            ${metrics.scrapPercentage.trendDirection === 'up' ? '' : ''} ${Math.abs(metrics.scrapPercentage.trend)}%
                        </div>
                    </div>
                </div>
                <div class="kpi-card">
                    <div class="kpi-title">Downtime Events</div>
                    <div class="kpi-value">
                        <div class="kpi-value-number">${metrics.downtimeEvents.value}</div>
                        <div class="kpi-trend ${metrics.downtimeEvents.trendDirection === 'down' ? 'trend-up' : 'trend-down'}">
                            ${metrics.downtimeEvents.trendDirection === 'up' ? '' : ''} ${Math.abs(metrics.downtimeEvents.trend)}
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Shows an error message in the KPI summary section
         */
        function showKpiSummaryError() {
            const kpiSummaryElement = document.getElementById('kpiSummary');
            kpiSummaryElement.innerHTML = `
                <div class="error-message">
                    Unable to load KPI summary data. Please refresh the page or try again later.
                </div>
            `;
        }

        /**
         * Formats a complete display name for the card header
         * @param {Object} line - The line object with name, id, baseProduct
         * @returns {string} The formatted display name
         */
        function formatCardHeaderName(line) {
            if (!line) return '';
            
            // Extract supervisor name
            const supervisor = extractSupervisorName(line.id);
            
            // For PopUp lines, show "PopUp: Supervisor"
            if (line.isPopUpLine) {
                return supervisor ? `PopUp: ${supervisor}` : 'PopUp';
            }
            
            // For regular lines, show "Product: Supervisor"
            if (line.name) {
                let productName = line.name;
                
                // If line name includes base product, just use the first part
                if (productName.includes(':')) {
                    productName = productName.split(':')[0].trim();
                }
                
                // Use base product if available, otherwise use the line name
                const displayProduct = line.baseProduct || productName;
                
                return supervisor ? `${displayProduct}: ${supervisor}` : displayProduct;
            }
            
            return line.name || '';
        }

        /**
         * Shows a loading state in the dashboard grid
         */
        function showLoading() {
            Logger.info('Showing loading spinner');
            const dashboardGrid = document.getElementById('dashboardGrid');
            dashboardGrid.innerHTML = `
                <div class="loading-container">
                    <div class="loading-spinner"></div>
                </div>
            `;
            
            const kpiSummary = document.getElementById('kpiSummary');
            kpiSummary.innerHTML = `
                <div class="loading-container">
                    <div class="loading-spinner"></div>
                </div>
            `;
        }

        /**
         * Shows an error message for the entire dashboard
         * @param {string} message - The error message to display
         */
        function showError(message) {
            Logger.error(message);
            const dashboardGrid = document.getElementById('dashboardGrid');
            dashboardGrid.innerHTML = `
                <div class="error-message">
                    ${message}
                    <br><button id="retryButton" style="margin-top: 10px; padding: 5px 10px;">Retry</button>
                </div>
            `;
            
            // Add event listener to retry button
            document.getElementById('retryButton').addEventListener('click', initializeDashboard);
        }

        /**
         * Format numeric values for display
         * @param {number} value - The numeric value to format
         * @param {string} type - The type of value ('scheduleAttainment', 'labourCostPerUnit', etc.)
         * @returns {string} Formatted value for display
         */
        function formatNumericValue(value, type) {
            if (value === null || value === undefined) return '0';
            
            switch(type) {
                case 'scheduleAttainment':
                case 'scrapPercentage':
                    // Round percentage to 1 decimal place
                    return parseFloat(value).toFixed(1);
                case 'labourCostPerUnit':
                    // Round cost to 2 decimal places
                    return parseFloat(value).toFixed(2);
                case 'downtimeHours':
                    // Round hours to 1 decimal place
                    return parseFloat(value).toFixed(1);
                default:
                    return value.toString();
            }
        }

        /**
         * Capitalizes the first letter of a string
         * @param {string} str - The string to capitalize
         * @returns {string} The string with first letter capitalized
         */
        function capitalizeFirstLetter(str) {
            if (!str) return '';
            return str.charAt(0).toUpperCase() + str.slice(1);
        }

        /**
         * ======================================
         * DASHBOARD INITIALIZATION
         * ======================================
         */

        /**
         * Initializes the dashboard by fetching and rendering data
         */
        async function initializeDashboard() {
            // Initialize logger
            Logger.init();
            Logger.info('Initializing dashboard');
            
            // Show loading state
            showLoading();
            
            try {
                // Fetch operational data
                const opsData = await fetchOpsData();
                
                // Store data globally for detail view
                window.dashboardData = opsData;
                
                // If current date range is not set, get default based on user preferences
                if (!currentDateRange.start || !currentDateRange.end) {
                    // Get default range based on week cycle preference
                    const defaultRange = getDefaultDateRange();
                    currentDateRange.start = defaultRange.start;
                    currentDateRange.end = defaultRange.end;
                    Logger.info(`Using default date range based on cycle preference (${weekCycleStartDay}): ${currentDateRange.start} to ${currentDateRange.end}`);
                }
                
                // Filter data by date range
                const filteredData = filterDataByDateRange(opsData, currentDateRange.start, currentDateRange.end);
                
                if (filteredData.length === 0) {
                    Logger.warn('No data available for selected date range');
                    showError('No data available for the selected date range. Please try a different date range.');
                    return;
                }
                
                // Transform data for UI
                const transformedData = transformOpsData(opsData, filteredData);
                
                // Render dashboard
                renderDashboard(transformedData);
                
                // Update period button text to match current period
                const periodToggle = document.getElementById('periodToggle');
                periodToggle.textContent = currentPeriod.charAt(0).toUpperCase() + currentPeriod.slice(1);
                
                Logger.info('Dashboard initialization completed successfully');
            } catch (error) {
                Logger.error('Error initializing dashboard', error);
                showError('Unable to load dashboard data. Please check your connection and try again.');
            }
        }

        function transformProductionLines(lineGroups) {
    const lines = [];
    Logger.info(`Transforming ${Object.keys(lineGroups).length} line groups into display format`);
    
    // Map with fixed positions for known lines
    const positionMapping = {
        'scd-line': { row: 1, col: 1 },
        'levo-line': { row: 1, col: 2 },
        'nosi-scalpel': { row: 1, col: 3 }, // This will be used for assembly
        'nosi-scalpel-assembly': { row: 1, col: 3 },
        'mvokwe-3rd line': { row: 1, col: 4 }, // This will be used for UBT
        'mvokwe-3rd-line-ubt': { row: 1, col: 4 },
        'sum-line': { row: 2, col: 1 },
        'popup-line': { row: 2, col: 2 },
        'nosi-scalpel-packaging': { row: 2, col: 3 },
        'mvokwe-3rd-line-scd': { row: 2, col: 4 },
            // Add these mappings to match actual IDs
    'apelele-scd': { row: 1, col: 1 },
    'luthando-sum': { row: 2, col: 1 },
    'siyabonga-levo': { row: 1, col: 2 },
    'mvokwe-popup': { row: 2, col: 2 }
    };
    
    // Process each line group
    for (const [groupKey, group] of Object.entries(lineGroups)) {
        Logger.info(`Processing line group: ${groupKey}`);
        
        // Skip if no records
        if (!group.records || group.records.length === 0) {
            Logger.warn(`No records for line group: ${groupKey}`);
            continue;
        }
        
        // Start building the line object
        const line = {
            id: group.id,
            name: group.name || 'Unknown Line',
            color: getHeaderColorClass(group.color || 'blue'),
            baseProduct: group.baseProduct,
            variants: [],
            isPopUpLine: (group.type === 'popup' || groupKey.includes('popup')),
            timelineSegments: []
        };
        
        // Handle special cases for Scalpel and 3rd line
        if (groupKey.includes('nosi-scalpel')) {
            if (groupKey.includes('packaging')) {
                line.id = 'nosi-scalpel-packaging';
                line.name = 'Scalpel: Packaging';
            } else {
                line.id = 'nosi-scalpel-assembly';
                line.name = 'Scalpel: Assembly';
            }
        }
        else if (groupKey.includes('mvokwe-3rd')) {
            if (group.baseProduct === 'SCD') {
                line.id = 'mvokwe-3rd-line-scd';
                line.name = 'SCD: Mvokwe (3rd)';
            } else {
                line.id = 'mvokwe-3rd-line-ubt';
                line.name = 'UBT: Mvokwe (3rd)';
            }
        }
        
        // Set position based on mapping
        const position = positionMapping[line.id] || positionMapping[group.id];
        if (position) {
            line.row = position.row;
            line.col = position.col;
        } else {
            // Use default position if not found in mapping
            Logger.warn(`No position mapping found for ${line.id}, defaulting to 1-1`);
            line.row = 1;
            line.col = 1;
        }
        
        // Group records by variant
        const variantGroups = {};
        group.records.forEach(record => {
            const variant = record.Variant || 'Standard';
            if (!variantGroups[variant]) {
                variantGroups[variant] = [];
            }
            variantGroups[variant].push(record);
        });
        
        // Extract latest variants
        const variantNames = Object.keys(variantGroups);
        
        // Sort records by date to find the most recent variant
        const latestRecords = {};
        variantNames.forEach(variant => {
            const records = variantGroups[variant];
            records.sort((a, b) => new Date(b.Date) - new Date(a.Date));
            latestRecords[variant] = records[0];
        });
        
        // Sort variants by recency
        const sortedVariants = variantNames.sort((a, b) => {
            return new Date(latestRecords[b].Date) - new Date(latestRecords[a].Date);
        });
        
        // Create variant objects
        sortedVariants.forEach((variantName, index) => {
            const records = variantGroups[variantName];
            
            // Calculate metrics for this variant
            const metrics = calculateVariantMetrics(records);
            
            // Calculate trends (comparing to previous periods)
            const trends = calculateVariantTrends(records);
            
            // Determine variant status
            let status = 'ENDED';
            const latestDate = new Date(latestRecords[variantName].Date);
            const today = new Date();
            const daysSince = Math.floor((today - latestDate) / (1000 * 60 * 60 * 24));
            
            if (daysSince <= 7) {
                status = 'ACTIVE';
            } else if (daysSince <= 30) {
                status = 'STANDBY';
            }
            
            // Create variant object
            const variant = {
                name: variantName,
                isCurrentVariant: index === 0, // First variant is current
                status: status,
                metrics: metrics,
                trends: trends,
                timeline: [] // Add timeline data if available
            };
            
            line.variants.push(variant);
        });
        
        // If this is a PopUp line, add recent runs
        if (line.isPopUpLine) {
            line.status = line.variants[0]?.status || 'ENDED';
            line.statusText = line.status === 'ACTIVE' ? 'Currently Active' : 
                             (line.status === 'STANDBY' ? 'Ready for Next Run' : 'No Active Run');
            
            line.recentRuns = group.records
                .sort((a, b) => new Date(b.Date) - new Date(a.Date))
                .slice(0, 5) // Take 5 most recent
                .map(record => ({
                    date: new Date(record.Date).toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
                    variant: record.Variant || 'Standard',
                    attainment: parseFloat(record['Schedule Attainment'] || 0).toFixed(1),
                    scrapPercentage: parseFloat(record['Scrap Cost as % of Production Value'] || 0).toFixed(1)
                }));
        }
        
        // Add the processed line to the array
        lines.push(line);
        Logger.info(`Added line: ${line.name} with ${line.variants.length} variants`);
    }
    
    return lines;
}

/**
 * Calculate metrics for a variant from its records
 */
function calculateVariantMetrics(records) {
    if (!records || records.length === 0) {
        return {
            scheduleAttainment: 0,
            labourCostPerUnit: 0,
            scrapPercentage: 0,
            downtimeHours: 0
        };
    }
    
    let totalScheduleAttainment = 0;
    let totalLabourCost = 0;
    let totalScrapPercentage = 0;
    let totalDowntime = 0;
    
    records.forEach(record => {
        totalScheduleAttainment += parseFloat(record['Schedule Attainment'] || 0);
        totalLabourCost += parseFloat(record['Staff Cost'] || 0);
        totalScrapPercentage += parseFloat(record['Scrap Cost as % of Production Value'] || 0);
        totalDowntime += parseFloat(record['Downtime Duration (min)'] || 0);
    });
    
    const count = records.length;
    
    return {
        scheduleAttainment: (totalScheduleAttainment / count).toFixed(1),
        labourCostPerUnit: (totalLabourCost / count).toFixed(0),
        scrapPercentage: (totalScrapPercentage / count).toFixed(1),
        downtimeHours: (totalDowntime / 60).toFixed(1) // Convert minutes to hours
    };
}

/**
 * Calculate trends for a variant
 */
function calculateVariantTrends(records) {
    // Default trends - used if there's not enough data
    const defaultTrends = {
        scheduleAttainment: { direction: 'up', value: 0 },
        labourCostPerUnit: { direction: 'down', value: 0 },
        scrapPercentage: { direction: 'down', value: 0 },
        downtimeHours: { direction: 'down', value: 0 }
    };
    
    if (!records || records.length < 2) {
        return defaultTrends;
    }
    
    // Sort by date, newest first
    records.sort((a, b) => new Date(b.Date) - new Date(a.Date));
    
    // Split into two halves for comparison
    const midpoint = Math.floor(records.length / 2);
    const recentRecords = records.slice(0, midpoint);
    const olderRecords = records.slice(midpoint);
    
    // Calculate metrics for each period
    const recentMetrics = calculateVariantMetrics(recentRecords);
    const olderMetrics = calculateVariantMetrics(olderRecords);
    
    // Calculate percentage changes
    const scheduleChange = olderMetrics.scheduleAttainment > 0 ? 
        ((recentMetrics.scheduleAttainment - olderMetrics.scheduleAttainment) / olderMetrics.scheduleAttainment) * 100 : 0;
    
    const labourCostChange = olderMetrics.labourCostPerUnit > 0 ? 
        ((recentMetrics.labourCostPerUnit - olderMetrics.labourCostPerUnit) / olderMetrics.labourCostPerUnit) * 100 : 0;
    
    const scrapChange = olderMetrics.scrapPercentage > 0 ? 
        ((recentMetrics.scrapPercentage - olderMetrics.scrapPercentage) / olderMetrics.scrapPercentage) * 100 : 0;
    
    const downtimeChange = olderMetrics.downtimeHours > 0 ? 
        ((recentMetrics.downtimeHours - olderMetrics.downtimeHours) / olderMetrics.downtimeHours) * 100 : 0;
    
    return {
        scheduleAttainment: {
            direction: scheduleChange >= 0 ? 'up' : 'down',
            value: Math.abs(scheduleChange).toFixed(1)
        },
        labourCostPerUnit: {
            direction: labourCostChange >= 0 ? 'up' : 'down',
            value: Math.abs(labourCostChange).toFixed(1)
        },
        scrapPercentage: {
            direction: scrapChange >= 0 ? 'up' : 'down',
            value: Math.abs(scrapChange).toFixed(1)
        },
        downtimeHours: {
            direction: downtimeChange >= 0 ? 'up' : 'down',
            value: Math.abs(downtimeChange).toFixed(1)
        }
    };
}
        /**
         * ======================================
         * CARD RENDERING
         * ======================================
         */

        /**
         * Renders a production line card
         * @param {Object} line - The production line data
         * @returns {string} HTML for the line card
         */
        function renderLineCard(line) {
            // Log the line details for debugging
            Logger.info(`Rendering card for line: ${line.name}`);
            
            // Handle PopUp line card differently
            if (line.isPopUpLine) {
                return renderPopUpLineCard(line);
            }
            
            // Format the display name for the card header
            const displayName = formatCardHeaderName(line);
            
            // Check if the line has a variants array
            if (!line.variants || !Array.isArray(line.variants) || line.variants.length === 0) {
                Logger.warn(`No variants available for line: ${line.name}`);
                return `
                    <div class="line-card ${line.isDoubleHeight ? 'card-double-height' : ''} ${line.cssClass || ''}" style="${line.customStyle || ''}" data-line-id="${line.id}">
                        <div class="line-card-header ${line.color}">
                            <div class="card-title">${displayName}</div>
                            <div class="card-actions">
                                <div class="enlarge-icon" onclick="showDetailView('${line.id}')">
                                    <i class="fas fa-expand-alt"></i>
                                </div>
                            </div>
                        </div>
                        <div class="line-card-content">
                            <div class="error-message">No variant data available for this line.</div>
                        </div>
                    </div>
                `;
            }
            
            // Get current variant (first one that's marked as current)
            const currentVariant = line.variants.find(v => v.isCurrentVariant);
            
            if (!currentVariant) {
                Logger.warn(`No current variant found for line: ${line.name}`);
            } else {
                Logger.info(`Current variant for ${line.name}: ${currentVariant.name}`);
            }
            
            // Get previous variant for special cases (double height card)
            const previousVariant = line.isDoubleHeight ? 
                line.variants.find(v => !v.isCurrentVariant) : null;
            
            if (line.isDoubleHeight && previousVariant) {
                Logger.info(`Previous variant for ${line.name}: ${previousVariant.name}`);
            }
            
            let variantSections = '';
            
            // Add current variant section if available
            if (currentVariant) {
                // Combined variant info and timeline in one element
                variantSections += `
                    <div class="variant-combined">
                        <div class="variant-info" style="margin-bottom: 0;">
                            <div class="variant-label">Variant: <span class="variant-name">${currentVariant.name}</span>
                                <span class="status-badge status-${currentVariant.status.toLowerCase()}" style="display: inline-block; margin-left: 8px; height: 16px; font-size: 9px; padding: 1px 6px;">${currentVariant.status}</span>
                            </div>
                            <div class="timeline-container" style="width: 120px; height: 20px; margin-left: auto; display: ${line.timelineSegments && line.timelineSegments.length > 0 ? 'block' : 'none'};">
                                ${line.timelineSegments && line.timelineSegments.length > 0 ? 
                                `<div style="font-size: 8px; text-align: center; color: var(--text-light);">Previous Variants</div>` + 
                                renderTimelineSegments(line.timelineSegments) : 
                                ''}
                            </div>
                        </div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-title">Schedule Attainment</div>
                            <div class="metric-value ${valueToCssClass(currentVariant.metrics.scheduleAttainment, 'scheduleAttainment')}">
                                ${currentVariant.metrics.scheduleAttainment}%
                                <div class="metric-trend ${currentVariant.trends.scheduleAttainment.direction === 'up' ? 'trend-up' : 'trend-down'}">
                                    ${currentVariant.trends.scheduleAttainment.direction === 'up' ? '' : ''} ${currentVariant.trends.scheduleAttainment.value}%
                                </div>
                            </div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Labour Cost/Unit</div>
                            <div class="metric-value ${valueToCssClass(currentVariant.metrics.labourCostPerUnit, 'labourCostPerUnit')}">
                                R${currentVariant.metrics.labourCostPerUnit}
                                <div class="metric-trend ${currentVariant.trends.labourCostPerUnit.direction === 'down' ? 'trend-up' : 'trend-down'}">
                                    ${currentVariant.trends.labourCostPerUnit.direction === 'up' ? '' : ''} ${currentVariant.trends.labourCostPerUnit.value}%
                                </div>
                            </div>
                        </div>
                        <div class="metric-card">
                        <div class="metric-title">% Scrap</div>
                            <div class="metric-value ${valueToCssClass(currentVariant.metrics.scrapPercentage, 'scrapPercentage')}">
                                ${currentVariant.metrics.scrapPercentage}%
                                <div class="metric-trend ${currentVariant.trends.scrapPercentage.direction === 'down' ? 'trend-up' : 'trend-down'}">
                                    ${currentVariant.trends.scrapPercentage.direction === 'up' ? '' : ''} ${currentVariant.trends.scrapPercentage.value}%
                                </div>
                            </div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Downtime</div>
                            <div class="metric-value ${valueToCssClass(currentVariant.metrics.downtimeHours, 'downtimeHours')}">
                                ${currentVariant.metrics.downtimeHours} hrs
                                <div class="metric-trend ${currentVariant.trends.downtimeHours.direction === 'down' ? 'trend-up' : 'trend-down'}">
                                    ${currentVariant.trends.downtimeHours.direction === 'up' ? '' : ''} ${currentVariant.trends.downtimeHours.value}%
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            } else {
                variantSections += `
                    <div class="error-message">No current variant data available for this line.</div>
                `;
            }
            
            // For double height card, add previous variant section
            if (line.isDoubleHeight && previousVariant) {
                variantSections += `
                    <div class="divider"></div>
                    
                    <div class="variant-info">
                        <div class="variant-label">Previous Variant: <span class="variant-name">${previousVariant.name}</span></div>
                        <div class="status-badge status-${previousVariant.status.toLowerCase()}">${previousVariant.status}</div>
                    </div>
                    
                    <div class="variant-history">
                        <div class="history-label">Recent History:</div>
                        <div class="timeline-container">
                            ${renderTimeline(previousVariant.timeline)}
                        </div>
                    </div>
                    
                    <div class="metrics-grid">
                        <div class="metric-card">
                            <div class="metric-title">Schedule Attainment</div>
                            <div class="metric-value ${valueToCssClass(previousVariant.metrics.scheduleAttainment, 'scheduleAttainment')}">
                                ${previousVariant.metrics.scheduleAttainment}%
                                <div class="metric-trend ${previousVariant.trends.scheduleAttainment.direction === 'up' ? 'trend-up' : 'trend-down'}">
                                    ${previousVariant.trends.scheduleAttainment.direction === 'up' ? '' : ''} ${previousVariant.trends.scheduleAttainment.value}%
                                </div>
                            </div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Labour Cost/Unit</div>
                            <div class="metric-value ${valueToCssClass(previousVariant.metrics.labourCostPerUnit, 'labourCostPerUnit')}">
                                R${previousVariant.metrics.labourCostPerUnit}
                                <div class="metric-trend ${previousVariant.trends.labourCostPerUnit.direction === 'down' ? 'trend-up' : 'trend-down'}">
                                    ${previousVariant.trends.labourCostPerUnit.direction === 'up' ? '' : ''} ${previousVariant.trends.labourCostPerUnit.value}%
                                </div>
                            </div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">% Scrap</div>
                            <div class="metric-value ${valueToCssClass(previousVariant.metrics.scrapPercentage, 'scrapPercentage')}">
                                ${previousVariant.metrics.scrapPercentage}%
                                <div class="metric-trend ${previousVariant.trends.scrapPercentage.direction === 'down' ? 'trend-up' : 'trend-down'}">
                                    ${previousVariant.trends.scrapPercentage.direction === 'up' ? '' : ''} ${previousVariant.trends.scrapPercentage.value}%
                                </div>
                            </div>
                        </div>
                        <div class="metric-card">
                            <div class="metric-title">Downtime</div>
                            <div class="metric-value ${valueToCssClass(previousVariant.metrics.downtimeHours, 'downtimeHours')}">
                                ${previousVariant.metrics.downtimeHours} hrs
                                <div class="metric-trend ${previousVariant.trends.downtimeHours.direction === 'down' ? 'trend-up' : 'trend-down'}">
                                    ${previousVariant.trends.downtimeHours.direction === 'up' ? '' : ''} ${previousVariant.trends.downtimeHours.value}%
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }
            
            return `
                <div class="line-card ${line.isDoubleHeight ? 'card-double-height' : ''} ${line.cssClass || ''}" style="${line.customStyle || ''}" data-line-id="${line.id}">
                    <div class="line-card-header ${line.color}">
                        <div class="card-title">${displayName}</div>
                        <div class="card-actions">
                            <div class="enlarge-icon" onclick="showDetailView('${line.id}')">
                                <i class="fas fa-expand-alt"></i>
                            </div>
                        </div>
                    </div>
                    <div class="line-card-content">
                        ${variantSections}
                    </div>
                </div>
            `;
        }

        /**
         * Renders a PopUp line card with recent runs table
         * @param {Object} line - The PopUp line data
         * @returns {string} HTML for the PopUp line card
         */
        function renderPopUpLineCard(line) {
            Logger.info(`Rendering PopUp line card: ${line.name}`);
            
            // Format the display name for the card header
            const displayName = formatCardHeaderName({...line, isPopUpLine: true});
            
            // Create table rows for recent runs
            let tableRows = '';
            
            if (line.recentRuns && line.recentRuns.length > 0) {
                line.recentRuns.forEach(run => {
                    tableRows += `
                        <tr>
                            <td>${run.date}</td>
                            <td>${run.variant}</td>
                            <td class="${valueToCssClass(run.attainment, 'scheduleAttainment')}">${run.attainment}%</td>
                            <td class="${valueToCssClass(run.scrapPercentage, 'scrapPercentage')}">${run.scrapPercentage}%</td>
                        </tr>
                    `;
                });
            } else {
                Logger.warn('No recent runs available for PopUp line');
                tableRows = `
                    <tr>
                        <td colspan="4" style="text-align: center;">No recent runs data available</td>
                    </tr>
                `;
            }
            
            return `
                <div class="line-card" data-line-id="${line.id}">
                    <div class="line-card-header ${line.color}">
                        <div class="card-title">${displayName}</div>
                        <div class="card-actions">
                            <div class="enlarge-icon" onclick="showDetailView('${line.id}')">
                                <i class="fas fa-expand-alt"></i>
                            </div>
                        </div>
                    </div>
                    <div class="line-card-content">
                        <div class="variant-combined">
                            <div class="variant-info" style="margin-bottom: 0;">
                                <div class="variant-label">Status: <span class="variant-name">${line.statusText}</span>
                                    <span class="status-badge status-${line.status.toLowerCase()}" style="display: inline-block; margin-left: 8px; height: 16px; font-size: 9px; padding: 1px 6px;">${line.status}</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="runs-table-container">
                            <div class="runs-table-title">Recent PopUp Runs</div>
                            <table class="runs-table">
                                <thead>
                                    <tr>
                                        <th>Date</th>
                                        <th>Variant</th>
                                        <th>Attainment</th>
                                        <th>Scrap %</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${tableRows}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Renders timeline segments
         * @param {Object} timeline - Timeline data for a variant
         * @returns {string} HTML for the timeline segments
         */
        function renderTimeline(timeline) {
            if (!timeline) {
                Logger.warn('No timeline data to render');
                return '';
            }
            
            // If timeline is already in segment format, use it directly
            if (Array.isArray(timeline)) {
                return renderTimelineSegments(timeline);
            }
            
            // Get color based on variant name
            const color = getVariantColor(timeline.label);
            
            // Custom label if provided, otherwise use variant name
            const label = timeline.label || '';
            
            // Default to a reasonable percentage if not specified or zero
            const percentage = timeline.percentage > 0 ? timeline.percentage : 100;
            
            // Create segment object
            const segment = {
                variant: label,
                displayText: label,
                width: `${percentage}%`,
                position: `${(100 - percentage) / 2}%`,
                color: color
            };
            
            return renderTimelineSegments([segment]);
        }

        /**
         * Renders timeline segments from array
         * @param {Array} segments - Timeline segments for a variant
         * @returns {string} HTML for the timeline segments
         */
        function renderTimelineSegments(segments) {
            if (!segments || segments.length === 0) {
                Logger.warn('No timeline segments to render');
                return '';
            }
            
            let timelineHtml = '';
            
            segments.forEach(segment => {
                // Default values if properties are missing
                const position = segment.position || '0';
                const width = segment.width || '100%';
                const color = segment.color || 'var(--timeline-blue)';
                const displayText = segment.displayText || '';
                
                timelineHtml += '<div class="timeline-segment" ' + 
                                'style="left: ' + position + '; ' + 
                                'width: ' + width + '; ' + 
                                'background-color: ' + color + ';">' +
                                displayText +
                                '</div>';
            });
            
            return timelineHtml;
        }

        /**
         * Gets a header color class from a line color
         * @param {string} lineColor - The line color from data
         * @returns {string} Header CSS class
         */
        function getHeaderColorClass(lineColor) {
            // If the color is already a header class, use it directly
            if (lineColor && lineColor.includes('header')) {
                return lineColor;
            }
            
            // Map common colors to header classes for CSS compatibility
            switch(lineColor && lineColor.toLowerCase()) {
                case 'blue': return 'blue-header';
                case 'orange': return 'orange-header';
                case 'purple': return 'purple-header';
                case 'black': return 'blue-header';
                case 'yellow': return 'orange-header';
                case 'grey': 
                case 'gray': 
                    return 'blue-header';
                case 'green': return 'orange-header';
                case 'pink': return 'purple-header';
                default: return 'blue-header'; // Default fallback
            }
        }

        /**
         * Gets color for a variant based on its name
         * @param {string} variantName - The variant name
         * @returns {string} CSS color value for the variant
         */
        function getVariantColor(variantName) {
            if (!variantName) return CONFIG.timelineColors.default;
            
            // Check for specific variant patterns in the name
            for (const [key, color] of Object.entries(CONFIG.timelineColors)) {
                if (variantName.includes(key)) {
                    return color;
                }
            }
            
            return CONFIG.timelineColors.default;
        }

        /**
         * Determines CSS class for a value based on its type and thresholds
         * @param {number} value - The value to evaluate
         * @param {string} type - The type of value ('scheduleAttainment', 'labourCostPerUnit', etc.)
         * @returns {string} CSS class name for the value
         */
        function valueToCssClass(value, type) {
            if (value === null || value === undefined) return '';
            
            // Default thresholds
            let goodThreshold, warningThreshold;
            let higherIsBetter = true;
            
            switch (type) {
                case 'scheduleAttainment':
                    goodThreshold = CONFIG.thresholds.scheduleAttainment.good;
                    warningThreshold = CONFIG.thresholds.scheduleAttainment.warning;
                    higherIsBetter = true;
                    break;
                    
                case 'labourCostPerUnit':
                    goodThreshold = CONFIG.thresholds.labourCostPerUnit.good;
                    warningThreshold = CONFIG.thresholds.labourCostPerUnit.warning;
                    higherIsBetter = false; // Lower is better for cost
                    break;
                    
                case 'scrapPercentage':
                    goodThreshold = CONFIG.thresholds.scrapPercentage.good;
                    warningThreshold = CONFIG.thresholds.scrapPercentage.warning;
                    higherIsBetter = false; // Lower is better for scrap percentage
                    break;
                    
                case 'downtimeHours':
                    goodThreshold = CONFIG.thresholds.downtimeHours.good;
                    warningThreshold = CONFIG.thresholds.downtimeHours.warning;
                    higherIsBetter = false; // Lower is better for downtime
                    break;
                    
                default:
                    return '';
            }
            
            // Determine color based on value compared to thresholds
            if (higherIsBetter) {
                if (value >= goodThreshold) return 'value-good';
                if (value >= warningThreshold) return 'value-warning';
                return 'value-danger';
            } else {
                if (value <= goodThreshold) return 'value-good';
                if (value <= warningThreshold) return 'value-warning';
                return 'value-danger';
            }
        }

        /**
         * Renders the schedule attainment chart with stacked bars for multiple variants
         * @param {Array} data - Filtered data for the line
         */
        function renderScheduleAttainmentChart(data) {
            const chartContainer = document.getElementById('scheduleAttainmentChart');
            
            // Sort data by date
            const sortedData = [...data].sort((a, b) => new Date(a.Date) - new Date(b.Date));
            
            // Group data by date and variant
            const groupedData = {};
            
            sortedData.forEach(record => {
                const date = new Date(record.Date);
                const dateKey = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                const variant = record.Variant || 'Unknown';
                
                if (!groupedData[dateKey]) {
                    groupedData[dateKey] = {};
                }
                
                if (!groupedData[dateKey][variant]) {
                    groupedData[dateKey][variant] = {
                        attainment: parseFloat(record['Schedule Attainment'] || 0),
                        count: 1
                    };
                } else {
                    // Average if we have multiple records for same date/variant
                    const current = groupedData[dateKey][variant];
                    current.attainment = (current.attainment * current.count + parseFloat(record['Schedule Attainment'] || 0)) / (current.count + 1);
                    current.count++;
                }
            });
            
            // Get unique date keys and variants
            const dateKeys = Object.keys(groupedData).sort((a, b) => {
                const dateA = new Date(a);
                const dateB = new Date(b);
                return dateA - dateB;
            });
            
            const allVariants = new Set();
            Object.values(groupedData).forEach(variants => {
                Object.keys(variants).forEach(variant => allVariants.add(variant));
            });
            const uniqueVariants = Array.from(allVariants);
            
            // Create chart HTML
            let html = '<div style="width: 100%; height: 100%;">';
            
            // Create axes and labels
            html += '<div style="display: flex; height: 100%;">';
            
            // Y-axis with better styling
            html += '<div style="width: 40px; height: 100%; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end; padding-right: 8px; color: var(--text-light); font-size: 11px; border-right: 1px solid #eee;">';
            html += '<div>100%</div>';
            html += '<div>75%</div>';
            html += '<div>50%</div>';
            html += '<div>25%</div>';
            html += '<div>0%</div>';
            html += '</div>';
            
            // Chart content
            html += '<div style="flex-grow: 1; height: 100%; display: flex; flex-direction: column;">';
            
            // Background grid lines
            html += '<div style="position: absolute; left: 40px; right: 0; height: calc(100% - 50px); display: flex; flex-direction: column; justify-content: space-between; pointer-events: none;">';
            html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.05);"></div>';
            html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.05);"></div>';
            html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.05);"></div>';
            html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.05);"></div>';
            html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.05);"></div>';
            html += '</div>';
            
            // Chart area
            html += '<div style="flex-grow: 1; display: flex; align-items: flex-end; gap: 2px; padding-top: 5px;">';
            
            // Define variant colors
            const variantColors = {
                'XL': 'var(--timeline-orange)',
                'S10': 'var(--timeline-red)',
                'S20': 'var(--timeline-blue)',
                'Plus': 'var(--timeline-purple)',
                'Regular': 'var(--timeline-blue)',
                'Deluxe': 'var(--timeline-purple)',
                'Standard': 'var(--timeline-blue)'
            };
            
            // Function to get color for variant
            const getVariantColor = (variant) => {
                // Check if variant name contains any of our color keys
                for (const [key, color] of Object.entries(variantColors)) {
                    if (variant.includes(key)) {
                        return color;
                    }
                }
                return 'var(--primary-blue)'; // Default color
            };
            
            // Render stacked bars
            dateKeys.forEach(dateKey => {
                const variants = groupedData[dateKey];
                
                html += '<div style="flex: 1; height: 100%; display: flex; flex-direction: column; justify-content: flex-end; align-items: center;">';
                
                // Target line (100%)
                html += '<div style="width: 100%; height: 2px; background-color: var(--danger-color); position: relative; bottom: 100%; z-index: 2;"></div>';
                
                // Stack bars for each variant
                let totalHeight = 0;
                Object.entries(variants).forEach(([variant, data]) => {
                    const variantColor = getVariantColor(variant);
                    const attainment = Math.round(data.attainment);
                    const barHeight = Math.min(attainment, 100 - totalHeight); // Cap at 100%
                    
                    if (barHeight > 0) {
                        html += '<div style="width: 60%; height: ' + barHeight + '%; background-color: ' + variantColor + '; position: relative;" ' + 
                                'title="' + variant + ': ' + attainment + '%">' +
                                '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 9px; color: white;">' + attainment + '%</div>' +
                                '</div>';
                        totalHeight += barHeight;
                    }
                });
                
                html += '</div>';
            });
            
            html += '</div>'; // End chart area
            
            // X-axis labels
            html += '<div style="height: 30px; display: flex; gap: 2px;">';
            dateKeys.forEach(dateKey => {
                html += '<div style="flex: 1; text-align: center; font-size: 10px; color: var(--text-light);">' + dateKey + '</div>';
            });
            html += '</div>';
            
            // Legend for variants
            html += '<div style="height: 30px; display: flex; justify-content: center; gap: 15px; margin-top: 5px;">';
            uniqueVariants.forEach(variant => {
                const variantColor = getVariantColor(variant);
                html += '<div style="display: flex; align-items: center; gap: 5px;">' +
                        '<div style="width: 10px; height: 10px; background-color: ' + variantColor + ';"></div>' +
                        '<div style="font-size: 10px;">' + variant + '</div>' +
                        '</div>';
            });
            html += '</div>';
            
            html += '</div>'; // End chart content
            html += '</div>'; // End axes and labels
            html += '</div>'; // End chart container
            
            chartContainer.innerHTML = html;
        }

        function renderLabourCostChart(data) {
    const chartContainer = document.getElementById('labourCostChart');
    
    // Sort data by date
    const sortedData = [...data].sort((a, b) => new Date(a.Date) - new Date(b.Date));
    
    // Extract data based on current view (labour or unit cost)
    const costType = detailViewState.costView || 'labour';
    
    // Format data for chart
    const chartData = sortedData.map(record => {
        const date = new Date(record.Date);
        const dateStr = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        
        // Use the appropriate cost field based on view
        const costValue = costType === 'unit' && record['Cost Per Unit'] ? 
            parseFloat(record['Cost Per Unit']) : 
            parseFloat(record['Staff Cost'] || 0);
            
        return {
            date: dateStr,
            cost: costValue,
            variant: record.Variant || 'Unknown'
        };
    });
    
    // Find min and max for scaling
    let minCost = Math.min(...chartData.map(d => d.cost));
    let maxCost = Math.max(...chartData.map(d => d.cost));
    
    // Add padding to min/max
    const padding = (maxCost - minCost) * 0.1;
    minCost = Math.max(0, minCost - padding);
    maxCost = maxCost + padding;
    
    // Create chart HTML
    let html = '<div style="width: 100%; height: 100%;">';
    
    // Create axes and labels
    html += '<div style="display: flex; height: 100%;">';
    
    // Y-axis with nicely formatted currency
    html += '<div style="width: 50px; height: 100%; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end; padding-right: 10px; color: var(--text-light); font-size: 12px;">';
    html += '<div>R' + Math.ceil(maxCost) + '</div>';
    html += '<div>R' + Math.round(minCost + (maxCost - minCost) * 0.75) + '</div>';
    html += '<div>R' + Math.round(minCost + (maxCost - minCost) * 0.5) + '</div>';
    html += '<div>R' + Math.round(minCost + (maxCost - minCost) * 0.25) + '</div>';
    html += '<div>R' + Math.floor(minCost) + '</div>';
    html += '</div>';
    
    // Chart content
    html += '<div style="flex-grow: 1; height: 100%; display: flex; flex-direction: column; position: relative;">';
    
    // Chart area with grid lines
    html += '<div style="flex-grow: 1; position: relative;">';
    
    // Background grid lines
    html += '<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between;">';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '</div>';
    
    if (chartData.length > 0) {
        // Calculate line points for SVG polyline
        const svgWidth = 100; // Using percentage
        const svgHeight = 100; // Using percentage
        
        // Group data by variant for multiple lines
        const variantGroups = {};
        chartData.forEach(item => {
            if (!variantGroups[item.variant]) {
                variantGroups[item.variant] = [];
            }
            variantGroups[item.variant].push(item);
        });
        
        // Create SVG container
        html += `<svg width="100%" height="100%" style="position: absolute; top: 0; left: 0; overflow: visible;">`;
        
        // Define variant colors
        const colors = {
            'XL1000SC': 'var(--primary-blue)',
            'XL1000+': 'var(--timeline-orange)',
            'XL1000S': 'var(--timeline-purple)',
            'SUM500V2': 'var(--primary-blue)',
            'XL1150SC': 'var(--timeline-purple)',
            'Default': 'var(--primary-blue)'
        };
        
        // Draw lines for each variant
        Object.entries(variantGroups).forEach(([variant, items]) => {
            if (items.length > 1) {
                const color = colors[variant] || colors['Default'];
                
                // Ensure items are sorted by date
                items.sort((a, b) => new Date(a.date) - new Date(b.date));
                
                // Calculate points string
                let pointsString = '';
                items.forEach((item, index) => {
                    // Calculate x position based on even spacing
                    const x = (index / (items.length - 1)) * svgWidth;
                    
                    // Calculate y position based on cost value
                    const y = svgHeight - ((item.cost - minCost) / (maxCost - minCost)) * svgHeight;
                    
                    pointsString += `${x},${y} `;
                });
                
                // Draw the polyline
                html += `<polyline 
                    points="${pointsString.trim()}" 
                    fill="none" 
                    stroke="${color}" 
                    stroke-width="2"
                    vector-effect="non-scaling-stroke"
                />`;
            }
        });
        
        html += '</svg>';
        
        // Add data points on top
        Object.entries(variantGroups).forEach(([variant, items]) => {
            const color = colors[variant] || colors['Default'];
            
            items.forEach((item, index) => {
                // Calculate positions exactly the same way as for the line
                const x = (index / (items.length - 1)) * 100;
                const y = 100 - ((item.cost - minCost) / (maxCost - minCost)) * 100;
                
                // Create dot using absolute positioning to ensure alignment with line
                html += `<div style="
                    position: absolute;
                    left: ${x}%;
                    top: ${y}%;
                    width: 8px;
                    height: 8px;
                    border-radius: 50%;
                    background-color: ${color};
                    transform: translate(-50%, -50%);
                    z-index: 2;
                " title="${item.date}: R${item.cost.toFixed(2)}"></div>`;
            });
        });
    }
    
    html += '</div>'; // End chart area
    
    // X-axis labels
    html += '<div style="height: 30px; display: flex; justify-content: space-between;">';
    
    // Get unique dates for x-axis
    const uniqueDates = [...new Set(chartData.map(item => item.date))];
    uniqueDates.sort((a, b) => new Date(a) - new Date(b));
    
    // Add date labels
    uniqueDates.forEach(date => {
        html += `<div style="text-align: center; font-size: 10px; color: var(--text-light);">${date}</div>`;
    });
    
    html += '</div>'; // End x-axis
    
    html += '</div>'; // End chart content
    html += '</div>'; // End axes and labels
    html += '</div>'; // End chart container
    
    chartContainer.innerHTML = html;
}
        
function renderScrapPercentageChart(data) {
    const chartContainer = document.getElementById('scrapPercentageChart');
    
    // Sort data by date
    const sortedData = [...data].sort((a, b) => new Date(a.Date) - new Date(b.Date));
    
    // Format data for chart
    const chartData = sortedData.map(record => {
        const date = new Date(record.Date);
        return {
            date: date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),
            scrap: parseFloat(record['Scrap Cost as % of Production Value'] || 0)
        };
    });
    
    // Log the chart data for debugging
    Logger.info(`Scrap percentage chart data: ${JSON.stringify(chartData.map(d => d.scrap))}`);
    
    // Check if we have any valid data
    if (chartData.length === 0 || chartData.every(d => d.scrap === 0)) {
        chartContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-light);">No scrap percentage data available.</div>';
        return;
    }
    
    // Find max for scaling (minimum 5% to have a reasonable scale)
    const maxScrap = Math.max(...chartData.map(d => d.scrap), 5);
    const yMax = Math.ceil(maxScrap * 1.1); // 10% padding
    
    // Create chart HTML
    let html = '<div style="width: 100%; height: 100%;">';
    
    // Create axes and labels
    html += '<div style="display: flex; height: 100%;">';
    
    // Y-axis
    html += '<div style="width: 50px; height: 100%; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end; padding-right: 10px; color: var(--text-light); font-size: 12px;">';
    html += '<div>' + yMax + '%</div>';
    html += '<div>' + Math.round(yMax * 0.75) + '%</div>';
    html += '<div>' + Math.round(yMax * 0.5) + '%</div>';
    html += '<div>' + Math.round(yMax * 0.25) + '%</div>';
    html += '<div>0%</div>';
    html += '</div>';
    
    // Chart content
    html += '<div style="flex-grow: 1; height: 100%; display: flex; flex-direction: column; position: relative;">';
    
    // Chart area
    html += '<div style="flex-grow: 1; position: relative;">';
    
    // Background grid lines
    html += '<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between;">';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '</div>';
    
    // Line chart
    if (chartData.length > 1) {
        // Calculate line points
        let points = '';
        chartData.forEach((item, index) => {
            const x = (index / (chartData.length - 1)) * 100;
            const y = 100 - (item.scrap / yMax) * 100;
            points += x + ',' + y + ' ';
        });
        
        // Create SVG for line
        html += '<svg width="100%" height="100%" style="position: absolute; top: 0; left: 0;">' +
                '<polyline ' + 
                'points="' + points.trim() + '" ' + 
                'fill="none" ' + 
                'stroke="var(--danger-color)" ' + 
                'stroke-width="2" ' + 
                '/>' +
                '</svg>';
        
        // Add data points
        chartData.forEach((item, index) => {
            const x = (index / (chartData.length - 1)) * 100;
            const y = 100 - (item.scrap / yMax) * 100;
            html += '<div style="position: absolute; top: ' + y + '%; left: ' + x + '%; transform: translate(-50%, -50%); width: 8px; height: 8px; background-color: var(--danger-color); border-radius: 50%;" title="' + item.date + ': ' + item.scrap.toFixed(2) + '%"></div>';
        });
    } else if (chartData.length === 1) {
        // For single data point, show a dot with label
        const item = chartData[0];
        const y = 100 - (item.scrap / yMax) * 100;
        html += '<div style="position: absolute; top: ' + y + '%; left: 50%; transform: translate(-50%, -50%); width: 8px; height: 8px; background-color: var(--danger-color); border-radius: 50%;" title="' + item.date + ': ' + item.scrap.toFixed(2) + '%"></div>';
        html += '<div style="position: absolute; top: ' + (y - 15) + '%; left: 50%; transform: translate(-50%, -50%); font-size: 12px; color: var(--danger-color);">' + item.scrap.toFixed(2) + '%</div>';
    }
    
    html += '</div>'; // End chart area
    
    // X-axis labels
    html += '<div style="height: 30px; display: flex; justify-content: space-between;">';
    chartData.forEach(item => {
        html += '<div style="text-align: center; font-size: 10px; color: var(--text-light);">' + item.date + '</div>';
    });
    html += '</div>';
    
    html += '</div>'; // End chart content
    html += '</div>'; // End axes and labels
    html += '</div>'; // End chart container
    
    chartContainer.innerHTML = html;
}
        
        function renderRejectPieChart(data) {
    const chartContainer = document.getElementById('rejectPieChart');
    if (!chartContainer) {
        Logger.error("rejectPieChart container not found in DOM");
        return;
    }
    
    // Extract reject reasons based on current view (qty or cost)
    const view = detailViewState.scrapView || 'qty';
    
    // Log the view mode
    Logger.info(`Rendering reject pie chart with view: ${view}`);
    
    // Get the relevant field based on view
    const field = view === 'qty' ? 
        'Top Rejects by QTY (Reason - Station - QTY - Cost)' : 
        'Top Rejects by Cost (Reason - Station - QTY - Cost)';
    
    // Collect reject data from all records
    const rejectMap = new Map();
    
    data.forEach(record => {
        if (record[field] && record[field] !== "No rejects" && !record[field].includes("No rejects")) {
            // Split by pipe to get individual entries
            const entries = record[field].split('|');
            
            entries.forEach(entry => {
                const trimmed = entry.trim();
                if (!trimmed) return;
                
                // Parse the entry - format: "1. Reason - Station - QTY: X - Cost: Y"
                const parts = trimmed.split(' - ');
                if (parts.length < 3) return;
                
                // Extract reason (remove numbering)
                let reason = parts[0].trim();
                reason = reason.replace(/^\d+\.\s+/, '');
                
                // Extract station
                const station = parts[1].trim();
                
                // Combine reason and station
                const reasonKey = `${reason} (${station})`;
                
                // Extract quantity and cost
                let qty = 0;
                let cost = 0;
                
                for (let i = 2; i < parts.length; i++) {
                    if (parts[i].includes('QTY:')) {
                        qty = parseFloat(parts[i].replace('QTY:', '').trim()) || 0;
                    } else if (parts[i].includes('Cost:')) {
                        cost = parseFloat(parts[i].replace('Cost:', '').trim()) || 0;
                    }
                }
                
                // Get the value based on view
                const value = view === 'qty' ? qty : cost;
                
                // Add to map
                if (rejectMap.has(reasonKey)) {
                    rejectMap.set(reasonKey, rejectMap.get(reasonKey) + value);
                } else {
                    rejectMap.set(reasonKey, value);
                }
            });
        }
    });
    
    // Convert to array and sort
    const rejectData = Array.from(rejectMap.entries())
        .map(([reason, value]) => ({ reason, value }))
        .sort((a, b) => b.value - a.value);
    
    Logger.info(`Extracted ${rejectData.length} reject reasons for pie chart`);
    
    // If no data, show message
    if (rejectData.length === 0) {
        chartContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-light);">No reject data available.</div>';
        return;
    }
    
    // Take top 5 and group the rest as "Other"
    let pieData = rejectData.slice(0, 5);
    
    // Calculate total
    const total = rejectData.reduce((sum, item) => sum + item.value, 0);
    
    // Add "Other" if needed
    if (rejectData.length > 5) {
        const otherValue = rejectData.slice(5).reduce((sum, item) => sum + item.value, 0);
        if (otherValue > 0) {
            pieData.push({
                reason: 'Other',
                value: otherValue
            });
        }
    }
    
    // Calculate percentages and angles for pie segments
    let startAngle = 0;
    const segments = pieData.map(item => {
        const percentage = (item.value / total) * 100;
        const angle = (percentage / 100) * 360;
        const segment = {
            reason: item.reason,
            percentage: percentage.toFixed(1),
            startAngle: startAngle,
            endAngle: startAngle + angle
        };
        startAngle += angle;
        return segment;
    });
    
    // Define colors
    const colors = [
        'var(--primary-blue)',
        'var(--timeline-orange)',
        'var(--timeline-purple)',
        'var(--timeline-red)',
        'var(--success-color)',
        'var(--text-light)'
    ];
    
    // Create layout with better sizing: pie chart on left, legend on right
    let html = `
        <div style="width: 100%; height: 100%; display: flex; flex-direction: row;">
            <!-- Pie Chart -->
            <div style="width: 50%; height: 100%; padding-right: 5px;">
                <svg width="100%" height="100%" viewBox="0 0 100 100" style="overflow: visible;">
                    <circle cx="50" cy="50" r="40" fill="#f5f7fa" />
    `;
    
    // Add pie segments
    segments.forEach((segment, index) => {
        const startRad = (segment.startAngle - 90) * (Math.PI / 180);
        const endRad = (segment.endAngle - 90) * (Math.PI / 180);
        
        const x1 = 50 + 40 * Math.cos(startRad);
        const y1 = 50 + 40 * Math.sin(startRad);
        const x2 = 50 + 40 * Math.cos(endRad);
        const y2 = 50 + 40 * Math.sin(endRad);
        
        // Determine if it's a large arc
        const largeArcFlag = segment.endAngle - segment.startAngle > 180 ? 1 : 0;
        
        // Create path for segment
        const path = `M 50 50 L ${x1} ${y1} A 40 40 0 ${largeArcFlag} 1 ${x2} ${y2} Z`;
        
        html += `<path d="${path}" fill="${colors[index % colors.length]}" />`;
    });
    
    html += `</svg>
            </div>`;
    
    // Add legend (now in its own column)
    html += `
            <!-- Legend -->
            <div style="width: 50%; height: 100%; overflow-y: auto; padding-left: 5px;">
                <div style="font-size: 11px; font-weight: bold; margin-bottom: 5px; color: var(--text-dark);">Reject Reasons</div>
    `;
    
    // Add legend items with better styling for readability
    segments.forEach((segment, index) => {
        const displayReason = segment.reason.length > 15 ? 
            segment.reason.substring(0, 15) + '...' : 
            segment.reason;
            
        html += `
            <div style="display: flex; align-items: center; margin-bottom: 4px; font-size: 10px;">
                <div style="width: 10px; height: 10px; background-color: ${colors[index % colors.length]}; margin-right: 5px; flex-shrink: 0;"></div>
                <div style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;" title="${segment.reason}">
                    ${displayReason} (${segment.percentage}%)
                </div>
            </div>
        `;
    });
    
    html += `
            </div>
        </div>
    `;
    
    chartContainer.innerHTML = html;
}
        
        function renderDowntimeChart(data) {
    const chartContainer = document.getElementById('downtimeChart');
    if (!chartContainer) {
        Logger.error("downtimeChart container not found in DOM");
        return;
    }
    
    // Sort data by date
    const sortedData = [...data].sort((a, b) => new Date(a.Date) - new Date(b.Date));
    
    // Extract downtime data
    const downtimeData = sortedData.map(record => {
        const date = new Date(record.Date);
        const dateKey = date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        
        // Parse the top downtime reasons if they exist
        let reasons = [];
        const downtimeField = 'Top Downtime by Cost (Reason - Machine - Cost - Downtime Min)';
        
        if (record[downtimeField] && 
            record[downtimeField] !== "No downtime" && 
            !record[downtimeField].includes("No downtime")) {
            
            // Split by pipe to get individual entries
            const entries = record[downtimeField].split('|');
            
            entries.forEach(entry => {
                const trimmed = entry.trim();
                if (!trimmed) return;
                
                // Parse entry - format: "1. Reason - Machine - Cost: X - Duration: Y min"
                const parts = trimmed.split(' - ');
                if (parts.length < 3) return;
                
                // Extract reason and machine
                let reason = parts[0].trim().replace(/^\d+\.\s+/, '');
                let machine = parts[1].trim();
                
                // Extract cost and duration
                let cost = 0;
                let duration = 0;
                
                for (let i = 2; i < parts.length; i++) {
                    if (parts[i].includes('Cost:')) {
                        cost = parseFloat(parts[i].replace('Cost:', '').trim()) || 0;
                    } else if (parts[i].includes('Duration:')) {
                        duration = parseFloat(parts[i].replace('Duration:', '').replace('min', '').trim()) || 0;
                    }
                }
                
                reasons.push({ reason, machine, cost, duration });
            });
        }
        
        // Get total downtime minutes
        const downtimeMins = parseFloat(record['Downtime Duration (min)'] || 0);
        
        return {
            date: dateKey,
            downtimeMinutes: downtimeMins,
            downtimeHours: downtimeMins / 60,
            reasons: reasons
        };
    });
    
    Logger.info(`Extracted downtime data for ${downtimeData.length} dates`);
    
    // If all entries have zero downtime, show a message
    if (downtimeData.every(item => item.downtimeMinutes === 0)) {
        chartContainer.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-light);">No downtime data available.</div>';
        return;
    }
    
    // Find max downtime for scaling
    const maxDowntimeHours = Math.max(...downtimeData.map(item => item.downtimeHours));
    const yMax = Math.ceil(Math.max(maxDowntimeHours, 1)); // At least 1 hour scale, round up
    
    // Create chart HTML
    let html = '<div style="width: 100%; height: 100%;">';
    
    // Create axes and labels
    html += '<div style="display: flex; height: 100%;">';
    
    // Y-axis
    html += '<div style="width: 50px; height: 100%; display: flex; flex-direction: column; justify-content: space-between; align-items: flex-end; padding-right: 10px; color: var(--text-light); font-size: 12px;">';
    html += '<div>' + yMax + ' hrs</div>';
    html += '<div>' + Math.round(yMax * 0.75) + ' hrs</div>';
    html += '<div>' + Math.round(yMax * 0.5) + ' hrs</div>';
    html += '<div>' + Math.round(yMax * 0.25) + ' hrs</div>';
    html += '<div>0 hrs</div>';
    html += '</div>';
    
    // Chart content
    html += '<div style="flex-grow: 1; height: 100%; display: flex; flex-direction: column; position: relative;">';
    
    // Chart area
    html += '<div style="flex-grow: 1; position: relative;">';
    
    // Background grid lines
    html += '<div style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: flex; flex-direction: column; justify-content: space-between;">';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '<div style="width: 100%; height: 1px; background-color: rgba(0,0,0,0.1);"></div>';
    html += '</div>';
    
    // Add bars
    html += '<div style="display: flex; height: 100%; padding-top: 10px;">';
    
    // Create a bar for each date
    downtimeData.forEach(item => {
        const height = (item.downtimeHours / yMax) * 100;
        
        // Determine bar color based on downtime hours
        let barColor = 'var(--primary-blue)';
        if (item.downtimeHours > CONFIG.thresholds.downtimeHours.warning) {
            barColor = 'var(--danger-color)';
        } else if (item.downtimeHours > CONFIG.thresholds.downtimeHours.good) {
            barColor = 'var(--warning-color)';
        }
        
        // Create tooltip text with reasons
        let tooltipText = `${item.date}: ${item.downtimeHours.toFixed(1)} hrs`;
        if (item.reasons.length > 0) {
            tooltipText += '\n\nReasons:';
            item.reasons.forEach(reason => {
                tooltipText += `\n ${reason.reason} (${reason.machine}): ${reason.duration} min`;
            });
        }
        
        html += '<div style="flex: 1; display: flex; justify-content: center; align-items: flex-end; height: 100%;">';
        if (height > 0) {
            html += `<div style="width: 70%; height: ${height}%; background-color: ${barColor};" title="${tooltipText}"></div>`;
        }
        html += '</div>';
    });
    
    html += '</div>'; // End bars
    
    html += '</div>'; // End chart area
    
    // X-axis labels
    html += '<div style="height: 30px; display: flex; justify-content: space-between;">';
    downtimeData.forEach(item => {
        html += '<div style="flex: 1; text-align: center; font-size: 10px; color: var(--text-light);">' + item.date + '</div>';
    });
    html += '</div>';
    
    html += '</div>'; // End chart content
    html += '</div>'; // End axes and labels
    html += '</div>'; // End chart container
    
    chartContainer.innerHTML = html;
}
        
function extractRejectReasons(data, view) {
    if (!data || data.length === 0) return [];
    
    // Define which field to use based on view
    const field = view === 'qty' ? 
        'Top Rejects by QTY (Reason - Station - QTY - Cost)' : 
        'Top Rejects by Cost (Reason - Station - QTY - Cost)';
    
    const reasonMap = new Map();
    
    // Process each record
    data.forEach(record => {
        // Skip if no reject data or "No rejects"
        if (!record[field] || record[field] === "No rejects") return;
        
        // Split by pipe character to get individual rejects
        const rejects = record[field].split('|');
        
        rejects.forEach(reject => {
            // Parse reject data
            // Format: "1. Broken hook - HNV Ass - QTY: 18 - Cost: 0"
            const parts = reject.trim().split(' - ');
            if (parts.length < 3) return;
            
            // Extract reason (removing numbering)
            let reason = parts[0].trim();
            reason = reason.replace(/^\d+\.\s+/, '');
            
            // Extract station
            const station = parts[1].trim();
            
            // Extract quantity and cost
            let qty = 0;
            let cost = 0;
            
            for (let i = 2; i < parts.length; i++) {
                if (parts[i].includes('QTY:')) {
                    qty = parseFloat(parts[i].replace('QTY:', '').trim()) || 0;
                } else if (parts[i].includes('Cost:')) {
                    cost = parseFloat(parts[i].replace('Cost:', '').trim()) || 0;
                }
            }
            
            // Create combined reason
            const fullReason = `${reason} (${station})`;
            
            // Add to map with appropriate value
            const value = view === 'qty' ? qty : cost;
            
            if (reasonMap.has(fullReason)) {
                reasonMap.set(fullReason, reasonMap.get(fullReason) + value);
            } else {
                reasonMap.set(fullReason, value);
            }
        });
    });
    
    // Convert map to array
    return Array.from(reasonMap.entries())
        .map(([reason, value]) => ({ reason, value }))
        .sort((a, b) => b.value - a.value)
        .slice(0, 5);  // Top 5 reasons
}

        
// Fix 3: Improve updateTopScrapList with proper DOM handling and debug output
function updateTopScrapList(data) {
    Logger.info(`Updating top scrap list for view: ${detailViewState.scrapView}`);
    
    // First ensure the container exists
    const scrapFooter = document.querySelector('.detail-metric-card:nth-child(3) .detail-metric-footer');
    if (!scrapFooter) {
        Logger.error("Scrap metric footer not found in DOM");
        return;
    }
    
    // Ensure the list title and container exist
    if (!scrapFooter.querySelector('.list-title')) {
        scrapFooter.innerHTML = `
            <div class="list-title">Top Reject Reasons</div>
            <div class="top-items-list" id="topScrapList"></div>
        `;
    }
    
    // Get the list element
    const listElement = document.getElementById('topScrapList');
    if (!listElement) {
        Logger.error("Element 'topScrapList' not found in DOM even after creation attempt");
        // Try to create it directly in the footer
        scrapFooter.innerHTML += '<div class="top-items-list" id="topScrapList"></div>';
    }
    
    // Try again with the newly created element
    const retryListElement = document.getElementById('topScrapList');
    if (!retryListElement) {
        Logger.error("Failed to create 'topScrapList' element");
        return;
    }
    
    // Sample some data to debug
    if (data && data.length > 0) {
        const sampleRecord = data[0];
        Logger.info(`Sample record reject fields: ${Object.keys(sampleRecord).filter(k => k.includes('Reject') || k.includes('Scrap')).join(', ')}`);
        
        if (sampleRecord['Top Rejects by QTY (Reason - Station - QTY - Cost)']) {
            Logger.info(`Sample reject data: ${sampleRecord['Top Rejects by QTY (Reason - Station - QTY - Cost)'].substring(0, 100)}...`);
        }
    }
    
    // Extract top rejects data based on current view
    const topItems = getTopScrapItems(data, detailViewState.scrapView);
    
    Logger.info(`Generated ${topItems.length} top scrap items for view: ${detailViewState.scrapView}`);
    
    if (topItems.length === 0) {
        retryListElement.innerHTML = '<div style="text-align: center; padding: 10px; color: var(--text-light);">No scrap data available.</div>';
        return;
    }
    
    // Generate HTML
    let html = '';
    topItems.forEach((item, index) => {
        html += `
            <div class="top-item">
                <div class="top-item-label">${index + 1}. ${item.reason}</div>
                <div class="top-item-value">${item.value}</div>
            </div>
        `;
    });
    
    retryListElement.innerHTML = html;
    Logger.info(`Updated scrap list with ${topItems.length} items`);
}

    function getTopScrapItems(data, view) {
    if (!data || data.length === 0) return [];
    
    // First try to extract data from formatted text strings
    const formattedField = view === 'qty' ? 
        'Top Rejects by QTY (Reason - Station - QTY - Cost)' :
        'Top Rejects by Cost (Reason - Station - QTY - Cost)';
    
    const parsedItems = [];
    
    // Process each record
    for (const record of data) {
        if (record[formattedField] && record[formattedField] !== "No rejects" && !record[formattedField].includes("No rejects")) {
            const rejectsText = record[formattedField];
            
            // Split by pipe character to get individual reject entries
            const rejectEntries = rejectsText.split('|');
            
            for (const entry of rejectEntries) {
                const trimmedEntry = entry.trim();
                if (!trimmedEntry) continue;
                
                // Parse out reason, station, quantity, and cost
                // Example: "1. Leaking - Seal - QTY: 68 - Cost: 81.61"
                const parts = trimmedEntry.split(' - ');
                if (parts.length >= 3) {  // Need at least reason, station, and some quantity/cost
                    // Extract reason (remove numbering if present)
                    let reason = parts[0].trim();
                    if (reason.match(/^\d+\.\s/)) {
                        reason = reason.replace(/^\d+\.\s/, '');
                    }
                    
                    // Extract station
                    const station = parts[1].trim();
                    
                    // Extract quantity and cost
                    let quantity = "0";
                    let cost = "0";
                    
                    for (let i = 2; i < parts.length; i++) {
                        if (parts[i].includes("QTY:")) {
                            quantity = parts[i].replace("QTY:", "").trim();
                        } else if (parts[i].includes("Cost:")) {
                            cost = parts[i].replace("Cost:", "").trim();
                        }
                    }
                    
                    // Add to parsed items with appropriate value format
                    parsedItems.push({
                        reason: `${reason} (${station})`,
                        value: view === 'qty' ? `${quantity} units` : `R ${cost}`
                    });
                }
            }
        }
    }
    
    // If we found items from formatted text, return them
    if (parsedItems.length > 0) {
        Logger.info(`Parsed ${parsedItems.length} reject items from formatted text field`);
        
        // Sort the items and take top 5
        return parsedItems
            .sort((a, b) => {
                // Extract numeric values for comparison
                const valA = parseFloat(a.value.replace(/[^0-9.]/g, ''));
                const valB = parseFloat(b.value.replace(/[^0-9.]/g, ''));
                return valB - valA;
            })
            .slice(0, 5);
    }
    
    // If no structured data found, check if we have reject rate data
    for (const record of data) {
        if (record['Reject Rate by Station'] && 
            record['Reject Rate by Station'] !== "No rejects" && 
            !record['Reject Rate by Station'].includes("No rejects")) {
            
            // Parse reject rates - format: "HNV Ass: 14.29%, Add Tube: 33.33%, Chamber-Lid Weld & P-Test: 42.86%, Tap Ass: 45.45%"
            const rejectRates = record['Reject Rate by Station'].split(',');
            const rejectItems = [];
            
            rejectRates.forEach(rate => {
                const parts = rate.trim().split(':');
                if (parts.length === 2) {
                    const station = parts[0].trim();
                    const percentage = parts[1].trim();
                    rejectItems.push({
                        reason: `${station}`,
                        value: view === 'qty' ? `${percentage}` : `${percentage}`
                    });
                }
            });
            
            if (rejectItems.length > 0) {
                Logger.info(`Parsed ${rejectItems.length} reject items from Reject Rate by Station`);
                return rejectItems
                    .sort((a, b) => {
                        const valA = parseFloat(a.value.replace(/[^0-9.]/g, ''));
                        const valB = parseFloat(b.value.replace(/[^0-9.]/g, ''));
                        return valB - valA;
                    })
                    .slice(0, 5);
            }
        }
    }
    
    // If still no data, return placeholder
    Logger.warn('No reject data found in records');
    return [{ reason: 'No reject data available', value: '-' }];
}

        
// Fix 4: Improve updateTopDowntimeList with proper DOM handling and debug output
function updateTopDowntimeList(data) {
    Logger.info(`Updating top downtime list for view: ${detailViewState.downtimeView}`);
    
    // First ensure the container exists
    const downtimeFooter = document.querySelector('.detail-metric-card:nth-child(4) .detail-metric-footer');
    if (!downtimeFooter) {
        Logger.error("Downtime metric footer not found in DOM");
        return;
    }
    
    // Ensure the list title and container exist
    if (!downtimeFooter.querySelector('.list-title')) {
        downtimeFooter.innerHTML = `
            <div class="list-title">Top Downtime Reasons</div>
            <div class="top-items-list" id="topDowntimeList"></div>
        `;
    }
    
    // Get the list element
    const listElement = document.getElementById('topDowntimeList');
    if (!listElement) {
        Logger.error("Element 'topDowntimeList' not found in DOM even after creation attempt");
        // Try to create it directly in the footer
        downtimeFooter.innerHTML += '<div class="top-items-list" id="topDowntimeList"></div>';
    }
    
    // Try again with the newly created element
    const retryListElement = document.getElementById('topDowntimeList');
    if (!retryListElement) {
        Logger.error("Failed to create 'topDowntimeList' element");
        return;
    }
    
    // Sample some data to debug
    if (data && data.length > 0) {
        const sampleRecord = data[0];
        Logger.info(`Sample record downtime fields: ${Object.keys(sampleRecord).filter(k => k.includes('Downtime')).join(', ')}`);
        
        if (sampleRecord['Top Downtime by Cost (Reason - Machine - Cost - Downtime Min)']) {
            Logger.info(`Sample downtime data: ${sampleRecord['Top Downtime by Cost (Reason - Machine - Cost - Downtime Min)'].substring(0, 100)}...`);
        }
    }
    
    // Extract top downtime data based on current view
    const topItems = getTopDowntimeItems(data, detailViewState.downtimeView);
    
    Logger.info(`Generated ${topItems.length} top downtime items for view: ${detailViewState.downtimeView}`);
    
    if (topItems.length === 0) {
        retryListElement.innerHTML = '<div style="text-align: center; padding: 10px; color: var(--text-light);">No downtime data available.</div>';
        return;
    }
    
    // Generate HTML
    let html = '';
    topItems.forEach((item, index) => {
        html += `
            <div class="top-item">
                <div class="top-item-label">${index + 1}. ${item.reason}</div>
                <div class="top-item-value">${item.value}</div>
            </div>
        `;
    });
    
    retryListElement.innerHTML = html;
    Logger.info(`Updated downtime list with ${topItems.length} items`);
}
        function getTopDowntimeItems(data, view) {
    if (!data || data.length === 0) return [];
    
    // First try to extract data from formatted text strings
    const formattedField = view === 'duration' ? 
        'Top Downtime by Downtime Min (Reason - Machine - Cost - Downtime Min)' :
        'Top Downtime by Cost (Reason - Machine - Cost - Downtime Min)';
    
    const parsedItems = [];
    
    // Process each record
    for (const record of data) {
        if (record[formattedField] && 
            record[formattedField] !== "No downtime" && 
            !record[formattedField].includes("No downtime")) {
            
            const downtimeText = record[formattedField];
            
            // Split by pipe character to get individual downtime entries
            const downtimeEntries = downtimeText.split('|');
            
            for (const entry of downtimeEntries) {
                const trimmedEntry = entry.trim();
                if (!trimmedEntry) continue;
                
                // Parse out reason, machine, cost, and duration
                // Format: "1. Equipment Failure - Machine A - Cost: 420.00 - Downtime Min: 60"
                const parts = trimmedEntry.split(' - ');
                if (parts.length >= 3) {  // Need at least reason, machine, and some cost/duration
                    // Extract reason (remove numbering if present)
                    let reason = parts[0].trim();
                    if (reason.match(/^\d+\.\s/)) {
                        reason = reason.replace(/^\d+\.\s/, '');
                    }
                    
                    // Extract machine
                    const machine = parts.length > 1 ? parts[1].trim() : '';
                    
                    // Extract cost and duration
                    let cost = "0";
                    let duration = "0";
                    
                    for (let i = 2; i < parts.length; i++) {
                        if (parts[i].includes("Cost:")) {
                            cost = parts[i].replace("Cost:", "").trim();
                        } else if (parts[i].includes("Downtime Min:")) {
                            duration = parts[i].replace("Downtime Min:", "").trim();
                        } else if (parts[i].includes("Downtime:")) {
                            duration = parts[i].replace("Downtime:", "").trim();
                            // Remove "min" if it's in the duration
                            duration = duration.replace("min", "").trim();
                        }
                    }
                    
                    // Create consistent reason format based on view
                    const displayReason = view === 'machine' ? 
                        machine : 
                        (view === 'reason' ? `${reason} (${machine})` : `${reason} (${machine})`);
                    
                    // Add to parsed items with appropriate value format
                    parsedItems.push({
                        reason: displayReason,
                        value: view === 'duration' ? `${duration} min` : `R ${cost}`
                    });
                }
            }
        }
    }
    
    // If we found items from formatted text, return them
    if (parsedItems.length > 0) {
        Logger.info(`Parsed ${parsedItems.length} downtime items from formatted text field`);
        
        // Sort the items and take top 5
        return parsedItems
            .sort((a, b) => {
                // Extract numeric values for comparison
                const valA = parseFloat(a.value.replace(/[^0-9.]/g, '')) || 0;
                const valB = parseFloat(b.value.replace(/[^0-9.]/g, '')) || 0;
                return valB - valA;
            })
            .slice(0, 5);
    }
    
    // Check for downtime duration values
    let hasDowntime = false;
    for (const record of data) {
        const downtimeDuration = parseFloat(record['Downtime Duration (min)'] || 0);
        if (downtimeDuration > 0) {
            hasDowntime = true;
            break;
        }
    }
    
    // Return appropriate message based on whether downtime exists
    if (!hasDowntime) {
        Logger.info('No downtime records found');
        return [{ reason: 'No downtime recorded', value: '0 min' }];
    } else {
        Logger.warn('Downtime duration found but no structured downtime data');
        return [{ reason: 'Total downtime', value: 'Details not available' }];
    }
}

        /**
         * Add event listeners when the DOM is loaded
         */
        document.addEventListener('DOMContentLoaded', () => {
            // Load user preferences
            loadUserPreferences();
            
            // Update cycle dropdown to match stored preference
            document.getElementById('cycleStartDay').value = weekCycleStartDay.toString();
            
            // Add event listeners for buttons
            document.getElementById('periodToggle').addEventListener('click', handlePeriodToggle);
            document.getElementById('refreshButton').addEventListener('click', handleRefresh);
            document.getElementById('dateRangeButton').addEventListener('click', handleDateRangeButton);
            document.getElementById('applyDateRange').addEventListener('click', handleApplyDateRange);
            document.getElementById('applyAndRememberCycle').addEventListener('click', handleApplyAndRememberCycle);
            document.getElementById('prevPeriodButton').addEventListener('click', navigateToPreviousPeriod);
            document.getElementById('nextPeriodButton').addEventListener('click', navigateToNextPeriod);
            
            // Add event listener for document click (to close dropdown)
            document.addEventListener('click', handleDocumentClick);
            
            // Detail view event listeners
            document.getElementById('modalClose').addEventListener('click', hideDetailView);
            document.getElementById('prevWeekBtn').addEventListener('click', navigateToPreviousWeek);
            document.getElementById('nextWeekBtn').addEventListener('click', navigateToNextWeek);
            document.getElementById('scrapQtyBtn').addEventListener('click', () => toggleScrapView('qty'));
            document.getElementById('scrapCostBtn').addEventListener('click', () => toggleScrapView('cost'));
            document.getElementById('downtimeReasonBtn').addEventListener('click', () => toggleDowntimeView('reason'));
            document.getElementById('downtimeMachineBtn').addEventListener('click', () => toggleDowntimeView('machine'));
            document.getElementById('downtimeDurationBtn').addEventListener('click', () => toggleDowntimeView('duration'));
            document.getElementById('labourCostBtn').addEventListener('click', () => toggleCostView('labour'));
            document.getElementById('unitCostBtn').addEventListener('click', () => toggleCostView('unit'));
            
            // Initialize the dashboard
            initializeDashboard();
            
            // Set up auto-refresh interval
            setInterval(initializeDashboard, CONFIG.refreshInterval);
        });

        // Make functions available in the global scope
        window.showDetailView = showDetailView;
        window.navigateToPreviousWeek = navigateToPreviousWeek;
        window.navigateToNextWeek = navigateToNextWeek;
        window.toggleScrapView = toggleScrapView;
        window.toggleDowntimeView = toggleDowntimeView;
        window.toggleCostView = toggleCostView;
    </script>
</body>
</html>
