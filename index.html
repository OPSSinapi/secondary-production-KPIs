<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Manufacturing Rejects Dashboard</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* ========== GLOBAL VARIABLES ========== */
        :root {
            /* Color scheme */
            --primary-color: #2c3e50;
            --primary-light: #34495e;
            --secondary-color: #3498db;
            --secondary-light: #5dade2;
            --secondary-dark: #2980b9;
            --accent-color: #e67e22;
            --accent-light: #f39c12;
            --success-color: #2ecc71;
            --danger-color: #e74c3c;
            --warning-color: #f1c40f;
            --info-color: #9b59b6;
            
            /* Action colors */
            --scrap-color: #e74c3c;
            --rts-color: #f39c12;
            --local-color: #2ecc71;
            
            /* Neutral colors */
            --background-color: #f5f7fa;
            --card-bg-color: #ffffff;
            --border-color: #e0e0e0;
            --text-color: #333333;
            --text-muted: #7f8c8d;
            
            /* Typography */
            --base-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --base-font-size: 14px;
            --small-font-size: 0.85rem;
            --heading-font-size: 1.1rem;
            --subheading-font-size: 0.95rem;
            
            /* Spacing - Adjusted for reduced whitespace */
            --space-xs: 3px;
            --space-sm: 6px;
            --space-md: 10px;
            --space-lg: 12px;
            --space-xl: 18px;
            
            /* Components */
            --border-radius-sm: 4px;
            --border-radius-md: 6px;
            --border-radius-lg: 8px;
            --card-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
            --card-shadow-hover: 0 4px 8px rgba(0, 0, 0, 0.1);
            
            /* Layout - Adjusted heights for more compact layout */
            --header-height: 45px;
            --filter-height: 50px;
            --metrics-height: 50px;
        }

        /* ========== RESET & BASE STYLES ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: var(--base-font);
        }
        
        html, body {
            height: 100%;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--text-color);
            font-size: var(--base-font-size);
            line-height: 1.4;
        }
        
        button, input, select {
            font-family: inherit;
            font-size: inherit;
        }
        
        /* ========== LAYOUT ========== */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100%;
            overflow: hidden;
        }
        
        .main-content {
            flex: 1;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }
        
        .content-area {
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }
        
        /* More compact header */
        .dashboard-header {
            height: var(--header-height);
            padding: 0 var(--space-md);
            background-color: var(--card-bg-color);
            box-shadow: 0 1px 3px rgba(0,0,0,0.12);
            display: flex;
            align-items: center;
            justify-content: space-between;
            z-index: 100;
        }
        
        .header-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
        }
        
        .header-title i {
            margin-right: var(--space-sm);
            color: var(--accent-color);
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .date-control {
            display: flex;
            align-items: center;
            gap: var(--space-sm);
        }
        
        .date-control label {
            font-weight: 500;
            color: var(--primary-color);
            font-size: var(--small-font-size);
        }
        
        .date-control input[type="date"] {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: 4px 6px;
            color: var(--text-color);
            font-size: var(--small-font-size);
        }
        
        .apply-date-btn {
            background-color: var(--secondary-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-sm);
            padding: 4px 10px;
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s;
            font-size: var(--small-font-size);
        }
        
        .apply-date-btn:hover {
            background-color: var(--secondary-dark);
        }
        
        /* More compact filter section */
        .filter-section {
            padding: var(--space-xs) var(--space-md);
            height: var(--filter-height);
            background-color: var(--card-bg-color);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: var(--space-md);
            overflow-x: auto;
            position: relative;
            z-index: 10; /* Lower than dropdowns */
        }
        
        .filter-group {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            white-space: nowrap;
            min-width: 160px;
        }
        
        .filter-group label {
            font-weight: 500;
            color: var(--primary-color);
            font-size: var(--small-font-size);
        }
        
        /* Multi-select dropdown */
        .multi-select {
            position: relative;
            width: 100%;
            min-width: 120px;
        }
        
        .multi-select-header {
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            padding: 3px 8px;
            font-size: var(--small-font-size);
            background-color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .multi-select-header:hover {
            border-color: var(--secondary-color);
        }
        
        .multi-select-text {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            flex: 1;
        }
        
        .multi-select-icon {
            margin-left: var(--space-xs);
            font-size: 10px;
            color: var(--text-muted);
        }
        
        .multi-select-dropdown {
            position: fixed; /* Change to fixed positioning */
            top: 100%;
            left: 0;
            width: 200px;
            max-height: 250px;
            background-color: white;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            z-index: 1000; /* Increase z-index significantly */
            display: none;
            margin-top: 2px;
            overflow: hidden;
        }
        
        .multi-select-dropdown.active {
            display: block;
        }
        
        .multi-select-search {
            width: 100%;
            padding: 6px 8px;
            border: none;
            border-bottom: 1px solid var(--border-color);
            font-size: var(--small-font-size);
        }
        
        .multi-select-options {
            max-height: 160px;
            overflow-y: auto;
        }
        
        .multi-select-option {
            padding: 6px 8px;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
            font-size: var(--small-font-size);
        }
        
        .multi-select-option:hover {
            background-color: #f5f5f5;
        }
        
        .multi-select-option.disabled {
            opacity: 0.5;
            pointer-events: none;
        }
        
        .multi-select-checkbox {
            margin-right: var(--space-xs);
        }
        
        .multi-select-actions {
            display: flex;
            justify-content: space-between;
            padding: 4px 8px;
            border-top: 1px solid var(--border-color);
        }
        
        .multi-select-btn {
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 2px 6px;
            font-size: var(--small-font-size);
            color: var(--secondary-color);
        }
        
        .multi-select-btn:hover {
            text-decoration: underline;
        }
        
        .filter-buttons {
            display: flex;
            gap: var(--space-sm);
            margin-left: auto;
        }
        
        .reset-btn {
            background-color: var(--danger-color);
            color: white;
            border: none;
            border-radius: var(--border-radius-sm);
            padding: 4px 10px;
            cursor: pointer;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            transition: background-color 0.2s;
            font-size: var(--small-font-size);
        }
        
        .reset-btn:hover {
            background-color: #c0392b;
        }
        
        /* More compact metrics bar */
        .metrics-bar {
            height: var(--metrics-height);
            padding: 0 var(--space-md);
            background-color: var(--card-bg-color);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
            overflow-x: auto;
        }
        
        .metrics-group {
            display: flex;
            align-items: center;
            gap: var(--space-lg);
        }
        
        .metric-item {
            display: flex;
            flex-direction: column;
        }
        
        .metric-value {
            font-size: 1.1rem;
            font-weight: 600;
            line-height: 1.2;
        }
        
        .metric-label {
            font-size: var(--small-font-size);
            color: var(--text-muted);
        }
        
        .metric-item.cost .metric-value {
            color: var(--accent-color);
        }
        
        .metric-item.qty .metric-value {
            color: var(--secondary-dark);
        }
        
        .metric-breakdown {
            display: flex;
            gap: var(--space-lg);
        }
        
        .type-metric {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            font-size: var(--small-font-size);
        }
        
        .type-percent {
            font-weight: 600;
            color: var(--primary-color);
        }
        
        .toggle-buttons {
            display: flex;
            gap: 1px;
            overflow: hidden;
            border-radius: var(--border-radius-sm);
            background-color: var(--border-color);
        }
        
        .toggle-btn {
            background-color: white;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            font-size: var(--small-font-size);
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .toggle-btn.active {
            background-color: var(--secondary-color);
            color: white;
        }

        /* Added styles for the action toggle buttons */
        .action-toggle-buttons {
            display: flex;
            gap: 1px;
            overflow: hidden;
            border-radius: var(--border-radius-sm);
            background-color: var(--border-color);
            margin-left: var(--space-md);
        }
        
        .action-toggle-btn {
            background-color: white;
            border: none;
            padding: 4px 8px;
            cursor: pointer;
            font-size: var(--small-font-size);
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .action-toggle-btn.active {
            background-color: var(--info-color);
            color: white;
        }
        
        .action-toggle-btn.action-scrap.active {
            background-color: var(--scrap-color);
        }
        
        .action-toggle-btn.action-rts.active {
            background-color: var(--rts-color);
        }
        
        .action-toggle-btn.action-local.active {
            background-color: var(--local-color);
        }
        
        .toggle-group {
            display: flex;
            align-items: center;
            gap: var(--space-md);
        }
        
        .toggle-label {
            font-size: var(--small-font-size);
            color: var(--text-muted);
            font-weight: 500;
        }
        
        /* Dashboard content with reduced padding */
        .dashboard-content {
            padding: var(--space-xs);
            display: flex;
            flex-direction: column;
            flex: 1;
            overflow: hidden;
        }
        
        /* Improved grid layout for better visibility */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: auto 1fr;
            gap: var(--space-xs);
            flex: 1;
            min-height: 0;
            overflow: hidden;
        }
        
        .dashboard-grid > * {
            min-height: 0;
        }
        
        /* Station row takes full width */
        .special-stations-row {
            grid-column: span 2;
            display: flex;
            gap: var(--space-xs);
            overflow: hidden;
            height: auto;
            min-height: 140px;
            max-height: 160px;
        }
        
        /* More compact station card */
        .station-card {
            padding: var(--space-xs);
            background-color: var(--card-bg-color);
            border-radius: var(--border-radius-sm);
            box-shadow: var(--card-shadow);
            flex: 1;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            border-top: 3px solid var(--info-color);
        }
        
        .station-card-title {
            margin-bottom: var(--space-xs);
            font-size: var(--small-font-size);
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .station-card-metrics {
            margin-bottom: var(--space-xs);
            display: flex;
            gap: var(--space-md);
        }
        
        .station-card-metric {
            display: flex;
            flex-direction: column;
        }
        
        .station-card-value {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .station-card-label {
            font-size: var(--small-font-size);
            color: var(--text-muted);
        }
        
        /* Make more efficient use of space in station card */
        .station-card-reasons {
            margin-top: var(--space-xs);
            flex: 1;
            min-height: 0;
            overflow: auto;
        }
        
        .station-card-reasons-title {
            font-size: var(--small-font-size);
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: var(--space-xs);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .reason-item {
            padding: 1px 0;
            display: flex;
            justify-content: space-between;
            font-size: var(--small-font-size);
        }
        
        .reason-item:not(:last-child) {
            border-bottom: 1px dashed var(--border-color);
        }
        
        .reason-name {
            color: var(--text-color);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
        }
        
        .reason-value {
            font-weight: 500;
            color: var(--primary-color);
            white-space: nowrap;
        }
        
        /* Station Navigation */
        .station-nav {
            display: flex;
            gap: var(--space-xs);
            margin-top: auto;
            padding-top: var(--space-xs);
            border-top: 1px solid var(--border-color);
        }
        
        .station-nav-btn {
            background: none;
            border: none;
            color: var(--secondary-color);
            cursor: pointer;
            font-size: var(--small-font-size);
            padding: 2px 4px;
        }
        
        .station-nav-btn:hover {
            color: var(--secondary-dark);
        }
        
        .station-nav-btn:disabled {
            color: var(--text-muted);
            cursor: not-allowed;
        }
        
        .station-nav-indicator {
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto;
            font-size: var(--small-font-size);
            color: var(--text-muted);
        }
        
        .station-pagination {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .station-page-btn {
            background: none;
            border: none;
            color: var(--secondary-color);
            cursor: pointer;
            font-size: 12px;
        }
        
        .station-page-btn.active {
            color: var(--primary-color);
            font-weight: bold;
        }
        
        .dashboard-card {
            background-color: var(--card-bg-color);
            border-radius: var(--border-radius-sm);
            box-shadow: var(--card-shadow);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        
        /* New grid layout positioning */
        /* First row, first column: Top Rejects Table */
        .top-rejects-card {
            grid-column: 1;
            grid-row: 2;
            min-height: 300px;
        }
        
        /* First row, second column: Daily Trend Chart */
        .trend-chart-card {
            grid-column: 2;
            grid-row: 2;
            height: calc(50% - var(--space-xs));
            margin-bottom: auto;
        }
        
        /* Second row, second column: Top Reject Reasons Chart */
        .reasons-chart-card {
            grid-column: 2;
            grid-row: 2;
            height: calc(50% - var(--space-xs));
            margin-top: auto;
        }
        
        /* More compact card headers */
        .card-header {
            padding: var(--space-xs) var(--space-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border-color);
        }
        
        .card-title {
            font-size: var(--small-font-size);
            font-weight: 600;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }
        
        .card-controls {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
        }
        
        /* Reduce padding in card content */
        .card-content {
            flex: 1;
            overflow: auto;
            padding: 0;
            position: relative;
            min-height: 0;
        }
        
        /* More compact table cells */
        .data-table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .data-table th, 
        .data-table td {
            padding: var(--space-xs) var(--space-sm);
            text-align: left;
            border-bottom: 1px solid var(--border-color);
            font-size: var(--small-font-size);
        }
        
        .data-table th {
            background-color: #f8f9fa;
            font-weight: 600;
            color: var(--primary-color);
            position: sticky;
            top: 0;
            z-index: 5;
        }
        
        .data-table tbody tr:hover {
            background-color: #f5f9ff;
        }
        
        .data-table th.sortable {
            cursor: pointer;
        }
        
        .data-table th.sortable:hover {
            background-color: #edf2f7;
        }
        
        .data-table th.sortable::after {
            content: "⇅";
            margin-left: 5px;
            color: #adb5bd;
        }
        
        .data-table th.sorted-asc::after {
            content: "↑";
            color: var(--secondary-color);
        }
        
        .data-table th.sorted-desc::after {
            content: "↓";
            color: var(--secondary-color);
        }
        
        /* Adjust chart containers for better visibility */
        .chart-container {
            padding: var(--space-xs);
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        /* Ensure full visibility of charts */
        .trend-chart-card, .reasons-chart-card {
            min-height: 200px;
        }
        
        /* Loading and empty states */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(255, 255, 255, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        
        .spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid var(--secondary-color);
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
            margin-bottom: var(--space-xs);
        }
        
        .loading-text {
            font-size: var(--small-font-size);
            color: var(--text-muted);
        }
        
        .empty-state {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100%;
            padding: var(--space-md);
            text-align: center;
        }
        
        .empty-icon {
            font-size: 1.5rem;
            color: var(--border-color);
            margin-bottom: var(--space-xs);
        }
        
        .empty-text {
            color: var(--text-muted);
            font-size: var(--small-font-size);
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Tooltips */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            z-index: 1000;
            pointer-events: none;
            font-size: 12px;
            max-width: 250px;
        }
        
        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }
        
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #cbd5e0;
            border-radius: 3px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: #a0aec0;
        }
        
        /* Adjust pagination controls to use less space */
        .pagination {
            padding: var(--space-xs) 0;
            display: flex;
            align-items: center;
            justify-content: center;
            border-top: 1px solid var(--border-color);
            gap: var(--space-xs);
        }
        
        .pagination-btn {
            background: none;
            border: none;
            color: var(--secondary-color);
            cursor: pointer;
            padding: 2px 6px;
            font-size: var(--small-font-size);
            border-radius: var(--border-radius-sm);
        }
        
        .pagination-btn:hover {
            background-color: #f8f9fa;
        }
        
        .pagination-btn:disabled {
            color: var(--text-muted);
            cursor: not-allowed;
        }
        
        .pagination-info {
            font-size: var(--small-font-size);
            color: var(--text-muted);
        }
        
        /* Comparison selector for trend chart */
        .comparison-select {
            padding: 2px 6px;
            font-size: var(--small-font-size);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius-sm);
            background-color: white;
        }
        
        /* More options button for cards */
        .more-options-btn {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: var(--small-font-size);
            padding: 2px;
            margin-left: var(--space-xs);
        }
        
        .more-options-btn:hover {
            color: var(--primary-color);
        }
        
        /* Reduce legend spacing */
        .chart-legend {
            margin-top: var(--space-xs);
            gap: var(--space-xs);
            display: flex;
            align-items: center;
            font-size: var(--small-font-size);
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }
        
        /* Trend line styles */
        .trend-line-legend {
            display: flex;
            align-items: center;
            gap: var(--space-xs);
            font-size: var(--small-font-size);
        }
        
        .trend-line-dash {
            width: 15px;
            height: 2px;
            background-color: #ccc;
        }
        
        .trend-line-dash.max {
            background-color: var(--danger-color);
            height: 2px;
        }
        
        .trend-line-dash.mean {
            background-color: var(--warning-color);
            height: 2px;
        }
        
        .trend-line-dash.min {
            background-color: var(--success-color);
            height: 2px;
        }
        
        /* Media Queries */
        @media (max-width: 1200px) {
            .dashboard-grid {
                grid-template-columns: 3fr 2fr;
            }
        }

        @media (max-width: 992px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
                grid-template-rows: auto auto auto auto;
            }
            
            .special-stations-row {
                grid-column: 1;
                grid-row: 1;
            }
            
            .top-rejects-card {
                grid-column: 1;
                grid-row: 2;
            }
            
            .trend-chart-card {
                grid-column: 1;
                grid-row: 3;
                height: auto;
                min-height: 250px;
                margin: 0;
            }
            
            .reasons-chart-card {
                grid-column: 1;
                grid-row: 4;
                height: auto;
                min-height: 250px;
                margin: 0;
            }
        }

        @media (max-width: 768px) {
            .filter-section {
                flex-direction: column;
                align-items: stretch;
                gap: var(--space-sm);
                padding: var(--space-sm);
                height: auto;
                min-height: var(--filter-height);
            }
            
            .filter-group {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .multi-select {
                width: 100%;
            }
            
            .filter-buttons {
                width: 100%;
                margin-top: var(--space-sm);
                justify-content: flex-end;
            }
            
            .metrics-bar {
                flex-direction: column;
                height: auto;
                padding: var(--space-sm);
                gap: var(--space-md);
            }
            
            .metrics-group {
                flex-wrap: wrap;
                justify-content: space-between;
            }
            
            .toggle-group {
                width: 100%;
                flex-wrap: wrap;
                justify-content: space-between;
            }
            
            .data-table th, 
            .data-table td {
                padding: var(--space-xs) var(--space-xs);
                font-size: calc(var(--small-font-size) - 1px);
            }
            
            /* Hide less important columns on very small screens */
            @media (max-width: 480px) {
                .data-table th:nth-child(2), 
                .data-table td:nth-child(2) {
                    display: none;
                }
            }
        }

.station-aliases {
    font-size: 0.7rem;
    font-weight: normal;
    color: var(--text-muted);
    margin-left: var(--space-xs);
}

.compact-reasons .reason-item {
    display: grid;
    grid-template-columns: 1fr auto;
    gap: var(--space-xs);
    padding: 2px 0;
    font-size: var(--small-font-size);
}

.compact-reasons .reason-info {
    display: flex;
    flex-direction: column;
}

.compact-reasons .reason-main {
    display: flex;
    justify-content: space-between;
}

.compact-reasons .reason-name {
    font-weight: 500;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    max-width: 100%;
}

.compact-reasons .reason-parts {
    font-size: 0.7rem;
    color: var(--text-muted);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

.compact-reasons .reason-value {
    text-align: right;
    white-space: nowrap;
}
    </style>
</head>
<body>
    <div class="app-container">
        <div class="main-content">
            <div class="content-area">
                <!-- Dashboard Header -->
                <header class="dashboard-header">
                    <div class="header-title">
                        <i class="fas fa-chart-bar"></i>
                        Manufacturing Rejects Dashboard
                    </div>
                    <div class="header-controls">
                        <div class="date-control">
                            <label for="date-from">From:</label>
                            <input type="date" id="date-from">
                        </div>
                        <div class="date-control">
                            <label for="date-to">To:</label>
                            <input type="date" id="date-to">
                        </div>
                        <button id="apply-date" class="apply-date-btn">
                            <i class="fas fa-calendar-check"></i> Apply
                        </button>
                    </div>
                </header>

                <!-- Filter Section -->
                <div class="filter-section">
                    <div class="filter-group">
                        <label>Supervisor:</label>
                        <div class="multi-select" id="supervisor-select">
                            <div class="multi-select-header">
                                <span class="multi-select-text">All Supervisors</span>
                                <i class="multi-select-icon fas fa-chevron-down"></i>
                            </div>
                            <div class="multi-select-dropdown">
                                <input type="text" class="multi-select-search" placeholder="Search...">
                                <div class="multi-select-options" id="supervisor-options">
                                    <!-- Options populated dynamically -->
                                </div>
                                <div class="multi-select-actions">
                                    <button class="multi-select-btn select-all-btn">Select All</button>
                                    <button class="multi-select-btn clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Product:</label>
                        <div class="multi-select" id="product-select">
                            <div class="multi-select-header">
                                <span class="multi-select-text">All Products</span>
                                <i class="multi-select-icon fas fa-chevron-down"></i>
                            </div>
                            <div class="multi-select-dropdown">
                                <input type="text" class="multi-select-search" placeholder="Search...">
                                <div class="multi-select-options" id="product-options">
                                    <!-- Options populated dynamically -->
                                </div>
                                <div class="multi-select-actions">
                                    <button class="multi-select-btn select-all-btn">Select All</button>
                                    <button class="multi-select-btn clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Variant:</label>
                        <div class="multi-select" id="variant-select">
                            <div class="multi-select-header">
                                <span class="multi-select-text">All Variants</span>
                                <i class="multi-select-icon fas fa-chevron-down"></i>
                            </div>
                            <div class="multi-select-dropdown">
                                <input type="text" class="multi-select-search" placeholder="Search...">
                                <div class="multi-select-options" id="variant-options">
                                    <!-- Options populated dynamically -->
                                </div>
                                <div class="multi-select-actions">
                                    <button class="multi-select-btn select-all-btn">Select All</button>
                                    <button class="multi-select-btn clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-group">
                        <label>Station:</label>
                        <div class="multi-select" id="station-select">
                            <div class="multi-select-header">
                                <span class="multi-select-text">All Stations</span>
                                <i class="multi-select-icon fas fa-chevron-down"></i>
                            </div>
                            <div class="multi-select-dropdown">
                                <input type="text" class="multi-select-search" placeholder="Search...">
                                <div class="multi-select-options" id="station-options">
                                    <!-- Options populated dynamically -->
                                </div>
                                <div class="multi-select-actions">
                                    <button class="multi-select-btn select-all-btn">Select All</button>
                                    <button class="multi-select-btn clear-btn">Clear All</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="filter-buttons">
                        <button id="reset-filters" class="reset-btn">
                            <i class="fas fa-undo"></i> Reset
                        </button>
                    </div>
                </div>

                <!-- Metrics Bar -->
                <div class="metrics-bar">
                    <div class="metrics-group">
                        <div class="metric-item cost">
                            <div class="metric-value" id="total-cost">R0</div>
                            <div class="metric-label">Total Cost</div>
                        </div>
                        
                        <div class="metric-item qty">
                            <div class="metric-value" id="total-qty">0</div>
                            <div class="metric-label">Total Quantity</div>
                        </div>
                        
                        <div class="metric-breakdown">
                            <div class="type-metric" id="scrap-metric">
                                <span>Scrap:</span>
                                <span id="scrap-percent" class="type-percent">0%</span>
                            </div>
                            <div class="type-metric" id="rts-metric">
                                <span>RTS:</span>
                                <span id="rts-percent" class="type-percent">0%</span>
                            </div>
                            <div class="type-metric" id="local-metric">
                                <span>Local:</span>
                                <span id="local-percent" class="type-percent">0%</span>
                            </div>
                        </div>
                    </div>
                    
                    <div class="toggle-group">
                        <div class="toggle-label">Sort By:</div>
                        <div class="toggle-buttons">
                            <button id="sort-by-qty" class="toggle-btn active">Qty</button>
                            <button id="sort-by-cost" class="toggle-btn">Cost</button>
                        </div>
                        
                        <!-- Action Selection Toggle Buttons -->
                        <div class="toggle-label">Filter Action:</div>
                        <div class="action-toggle-buttons" id="action-toggle">
                            <button id="action-all" class="action-toggle-btn active">All</button>
                            <button id="action-scrap" class="action-toggle-btn action-scrap">Scrap</button>
                            <button id="action-rts" class="action-toggle-btn action-rts">RTS</button>
                            <button id="action-local" class="action-toggle-btn action-local">Local</button>
                        </div>
                    </div>
                </div>

                <!-- Dashboard Content -->
                <div class="dashboard-content">
                    <div class="dashboard-grid">
                        <!-- Special Stations Row - Final Inspection Station -->
                        <div class="special-stations-row">
                            <div class="station-card" id="final-inspection-card">
                                <div class="station-card-title">
                                    <span id="station-title">Final Inspection Stations</span>
                                    <span id="station-aliases" class="station-aliases"></span>
                                    <i class="fas fa-info-circle"></i>
                                </div>
                                <div class="station-card-metrics">
                                    <div class="station-card-metric">
                                        <div class="station-card-value" id="final-inspection-qty">0</div>
                                        <div class="station-card-label">Quantity</div>
                                    </div>
                                    <div class="station-card-metric">
                                        <div class="station-card-value" id="final-inspection-cost">R0</div>
                                        <div class="station-card-label">Cost</div>
                                    </div>
                                </div>
                                
                                <div class="station-card-reasons">
                                    <div class="station-card-reasons-title">
                                        <span>Top Reasons</span>
                                        <div class="station-pagination" id="station-reasons-pagination">
                                            <button class="station-page-btn" data-page="1">1</button>
                                            <button class="station-page-btn" data-page="2">2</button>
                                            <button class="station-page-btn" data-page="3">3</button>
                                        </div>
                                    </div>
                                    <div id="station-reasons-container" class="compact-reasons">
                                        <!-- Reasons will be populated dynamically -->
                                    </div>
                                </div>
                                
                                <div class="station-nav">
                                    <button class="station-nav-btn" id="prev-station">
                                        <i class="fas fa-chevron-left"></i> Prev
                                    </button>
                                    <div class="station-nav-indicator">
                                        <span id="station-current">1</span>/<span id="station-total">3</span>
                                    </div>
                                    <button class="station-nav-btn" id="next-station">
                                        Next <i class="fas fa-chevron-right"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Top Rejects Table Card - first column -->
                        <div class="dashboard-card top-rejects-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <i class="fas fa-exclamation-triangle"></i> Top Rejects
                                </div>
                                <div class="card-controls">
                                    <span class="pagination-info" id="top-rejects-pagination-info">Showing 1-5 of 0</span>
                                    <button class="pagination-btn" id="prev-rejects" disabled>
                                        <i class="fas fa-chevron-left"></i>
                                    </button>
                                    <button class="pagination-btn" id="next-rejects" disabled>
                                        <i class="fas fa-chevron-right"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="card-content">
                                <table class="data-table" id="top-rejects-table">
                                    <thead>
                                        <tr>
                                            <th class="sortable" data-sort="station">Station</th>
                                            <th data-sort="parts">Parts</th>
                                            <th class="sortable" data-sort="reason">Reject Reason</th>
                                            <th class="sortable" data-sort="qty">QTY</th>
                                            <th class="sortable" data-sort="cost">Cost (R)</th>
                                            <!-- PartBatchNumber column is added dynamically when RTS is selected -->
                                        </tr>
                                    </thead>
                                    <tbody id="top-rejects-body">
                                        <!-- Data will be loaded here -->
                                    </tbody>
                                </table>
                                
                                <!-- Empty state (hidden by default) -->
                                <div class="empty-state" id="top-rejects-empty" style="display: none;">
                                    <div class="empty-icon">
                                        <i class="fas fa-database"></i>
                                    </div>
                                    <div class="empty-text">No reject data found for the selected filters.</div>
                                </div>
                                
                                <!-- Loading overlay (hidden by default) -->
                                <div class="loading-overlay" id="top-rejects-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <div class="loading-text">Loading data...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Trend Chart Card - top half of second column -->
                        <div class="dashboard-card trend-chart-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <i class="fas fa-chart-line"></i> Daily Rejects Trend
                                </div>
                                <div class="card-controls">
                                    <!-- Toggle between cost and quantity for the trend chart -->
                                    <div class="toggle-buttons">
                                        <button id="trend-view-qty" class="toggle-btn active">Qty</button>
                                        <button id="trend-view-cost" class="toggle-btn">Cost</button>
                                    </div>
                                    
                                    <!-- Comparison period selector -->
                                    <select id="comparison-period" class="comparison-select">
                                        <option value="none">No Comparison</option>
                                        <option value="previous">Previous Period</option>
                                        <option value="month">Month</option>
                                        <option value="qtd">QTD</option>
                                        <option value="ytd">YTD</option>
                                        <option value="1y">1 Year</option>
                                    </select>
                                </div>
                            </div>
                            <div class="card-content">
                                <div class="chart-container" id="trend-chart-container">
                                    <!-- Chart will be rendered here -->
                                </div>
                                
                                <!-- Chart legend -->
                                <div class="chart-legend" id="trend-chart-legend">
                                    <div class="legend-item">
                                        <div class="legend-color" style="background-color: var(--scrap-color);"></div>
                                        <span>Scrap</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background-color: var(--rts-color);"></div>
                                        <span>RTS</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-color" style="background-color: var(--local-color);"></div>
                                        <span>Local</span>
                                    </div>
                                    <div class="trend-line-legend">
                                        <div class="trend-line-dash max"></div>
                                        <span>Max</span>
                                    </div>
                                    <div class="trend-line-legend">
                                        <div class="trend-line-dash mean"></div>
                                        <span>Mean</span>
                                    </div>
                                    <div class="trend-line-legend">
                                        <div class="trend-line-dash min"></div>
                                        <span>Min (Non-Zero)</span>
                                    </div>
                                </div>
                                
                                <!-- Empty state (hidden by default) -->
                                <div class="empty-state" id="trend-chart-empty" style="display: none;">
                                    <div class="empty-icon">
                                        <i class="fas fa-chart-line"></i>
                                    </div>
                                    <div class="empty-text">No trend data available for the selected period.</div>
                                </div>
                                
                                <!-- Loading overlay (hidden by default) -->
                                <div class="loading-overlay" id="trend-chart-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <div class="loading-text">Generating chart...</div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Top Reasons Chart Card - bottom half of second column -->
                        <div class="dashboard-card reasons-chart-card">
                            <div class="card-header">
                                <div class="card-title">
                                    <i class="fas fa-exclamation-circle"></i> Top Reject Reasons
                                </div>
                                <div class="card-controls">
                                    <div class="toggle-buttons">
                                        <button id="reasons-view-qty" class="toggle-btn active">Qty</button>
                                        <button id="reasons-view-cost" class="toggle-btn">Cost</button>
                                    </div>
                                </div>
                            </div>
                            <div class="card-content">
                                <div class="chart-container" id="reasons-chart-container">
                                    <!-- Chart will be rendered here -->
                                </div>
                                
                                <!-- Empty state (hidden by default) -->
                                <div class="empty-state" id="reasons-chart-empty" style="display: none;">
                                    <div class="empty-icon">
                                        <i class="fas fa-chart-pie"></i>
                                    </div>
                                    <div class="empty-text">No reason data available for the selected filters.</div>
                                </div>
                                
                                <!-- Loading overlay (hidden by default) -->
                                <div class="loading-overlay" id="reasons-chart-loading" style="display: none;">
                                    <div class="spinner"></div>
                                    <div class="loading-text">Generating chart...</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <!-- Load libraries from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script>
    /**
     * Manufacturing Rejects Dashboard
     * 
     * A modular, maintainable dashboard for visualizing manufacturing reject data.
     * This application follows a modular pattern with clear separation of concerns:
     * 
     * 1. DataModule: Handles data loading, filtering, and manipulation
     * 2. UIModule: Manages UI interactions and rendering
     * 3. ChartModule: Creates and updates data visualizations
     * 4. DashboardModule: Orchestrates the overall application
     */

    /**
     * Utility Module
     * Provides helper functions used throughout the application
     */
    const Utils = (function() {
        // Format currency values
        const formatCurrency = (value) => {
            return 'R' + value.toFixed(2).replace(/\d(?=(\d{3})+\.)/g, '$&,');
        };
        
        // Format date objects to YYYY-MM-DD
        const formatDateForAPI = (date) => {
            return date.toISOString().split('T')[0];
        };
        
        // Format date for display
        const formatDateForDisplay = (dateString) => {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        };
        
        // Group array of objects by a property
        const groupBy = (array, key) => {
            return array.reduce((result, item) => {
                (result[item[key]] = result[item[key]] || []).push(item);
                return result;
            }, {});
        };
        
        // Safely access nested object properties
        const getNestedProperty = (obj, path, defaultValue = undefined) => {
            const pathArray = Array.isArray(path) ? path : path.split('.');
            let current = obj;
            
            for (let i = 0; i < pathArray.length; i++) {
                if (current === null || current === undefined) {
                    return defaultValue;
                }
                current = current[pathArray[i]];
            }
            
            return current === undefined ? defaultValue : current;
        };
        
        // Debounce function for performance
        const debounce = (func, wait) => {
            let timeout;
            return function(...args) {
                const context = this;
                clearTimeout(timeout);
                timeout = setTimeout(() => func.apply(context, args), wait);
            };
        };
        
        // Show loading state
        const showLoading = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'flex';
            }
        };
        
        // Hide loading state
        const hideLoading = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'none';
            }
        };
        
        // Show empty state
        const showEmpty = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'flex';
            }
        };
        
        // Hide empty state
        const hideEmpty = (elementId) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.style.display = 'none';
            }
        };
        
        // Generate a random ID
        const generateId = () => {
            return Math.random().toString(36).substring(2, 15);
        };
        
        // Calculate the date range for the last N days
        const getLastNDaysRange = (days) => {
            const end = new Date();
            const start = new Date();
            start.setDate(start.getDate() - days);
            return { start, end };
        };
        
        // Truncate text with ellipsis
        const truncateText = (text, maxLength) => {
            if (!text || text.length <= maxLength) return text;
            return text.substring(0, maxLength) + '...';
        };
        
        // Get comparison period date range
        const getComparisonDateRange = (currentStart, currentEnd, period) => {
            const currentRange = currentEnd - currentStart;
            const start = new Date(currentStart);
            const end = new Date(currentEnd);
            
            switch (period) {
                case 'previous':
                    // Previous period of same length
                    start.setTime(start.getTime() - currentRange);
                    end.setTime(end.getTime() - currentRange);
                    break;
                    
                case 'month':
                    // First day to last day of current month
                    start.setDate(1);
                    end.setDate(0); // Last day of previous month
                    end.setMonth(end.getMonth() + 2); // Last day of current month
                    break;
                    
                case 'qtd':
                    // First day of quarter to today
                    const quarterMonth = Math.floor(start.getMonth() / 3) * 3;
                    start.setMonth(quarterMonth);
                    start.setDate(1);
                    break;
                    
                case 'ytd':
                    // First day of year to today
                    start.setMonth(0);
                    start.setDate(1);
                    break;
                    
                case '1y':
                    // Same period one year ago
                    start.setFullYear(start.getFullYear() - 1);
                    end.setFullYear(end.getFullYear() - 1);
                    break;
                    
                default:
                    // No comparison
                    return null;
            }
            
            return { start, end };
        };
        
        // Calculate non-zero min, mean, and max from an array of numbers
        const calculateStats = (values) => {
            if (!values || values.length === 0) {
                return { min: 0, mean: 0, max: 0 };
            }
            
            // Filter out zero values for min calculation
            const nonZeroValues = values.filter(v => v > 0);
            
            const min = nonZeroValues.length > 0 ? Math.min(...nonZeroValues) : 0;
            const max = values.length > 0 ? Math.max(...values) : 0;
            const sum = values.reduce((a, b) => a + b, 0);
            const mean = values.length > 0 ? sum / values.length : 0;
            
            return { min, mean, max };
        };
        
        return {
            formatCurrency,
            formatDateForAPI,
            formatDateForDisplay,
            groupBy,
            getNestedProperty,
            debounce,
            showLoading,
            hideLoading,
            showEmpty,
            hideEmpty,
            generateId,
            getLastNDaysRange,
            truncateText,
            getComparisonDateRange,
            calculateStats
        };
    })();

    /**
     * Data Module
     * Handles data loading, filtering, and manipulation
     */
    const DataModule = (function() {
        // Private state
        let indexData = null;
        let rejectData = [];
        let filteredData = [];
        let loadedMonths = {};
        let comparisonData = null;
        let currentFilters = {
            dateFrom: null,
            dateTo: null,
            supervisor: [],
            product: [],
            variant: [],
            station: [],
            actionSelection: [] // Filter for ActionSelection
        };
        
        // Current table sorting parameters
        let currentTableSort = {
            sortBy: 'station',
            sortDirection: 'asc'
        };
        
        // Filter associations for interdependent filtering
        let filterAssociations = {
            supervisor: {},  // supervisor: { value: { product: [values], variant: [values], station: [values], actionSelection: [values] } }
            product: {},     // product: { value: { supervisor: [values], variant: [values], station: [values], actionSelection: [values] } }
            variant: {},     // variant: { value: { supervisor: [values], product: [values], station: [values], actionSelection: [values] } }
            station: {},     // station: { value: { supervisor: [values], product: [values], variant: [values], actionSelection: [values] } }
            actionSelection: {} // actionSelection: { value: { supervisor: [values], product: [values], variant: [values], station: [values] } }
        };
        
        // Final Inspection Station Aliases
        const finalInspectionAliases = ['Wrapping & Checkers', 'FI', 'Checkers'];
        
        // Other stations to track
        let stationGroups = {};
        
        // Initialize data module
        const init = async function() {
            try {
                // Fetch the index data that contains available periods
                const indexResponse = await fetch('RejectsIndex.json');
                if (!indexResponse.ok) {
                    throw new Error('Failed to load index data');
                }
                
                indexData = await indexResponse.json();
                
                // Set default date range (last 30 days or based on available data)
                const { start, end } = Utils.getLastNDaysRange(30);
                currentFilters.dateFrom = start;
                currentFilters.dateTo = end;
                
                // Initialize station groups
                stationGroups = {
                    'Final Inspection': finalInspectionAliases
                };
                
                return true;
            } catch (error) {
                console.error('Error initializing data module:', error);
                return false;
            }
        };
        
        // Load data for current date range
        const loadDataForDateRange = async function() {
            if (!indexData || !currentFilters.dateFrom || !currentFilters.dateTo) {
                return false;
            }
            
            try {
                console.log("Loading data for date range:", 
                    currentFilters.dateFrom.toISOString().split('T')[0], 
                    "to", 
                    currentFilters.dateTo.toISOString().split('T')[0]);
                
                // Get list of months needed for the date range
                const monthsToLoad = getMonthsInRange(
                    currentFilters.dateFrom, 
                    currentFilters.dateTo
                );
                
                console.log("Months to load:", monthsToLoad);
                
                if (monthsToLoad.length === 0) {
                    throw new Error('No data available for selected date range');
                }
                
                // Reset data arrays
                rejectData = [];
                
                // Load each required month
                for (const month of monthsToLoad) {
                    if (!loadedMonths[month]) {
                        try {
                            console.log(`Loading data for ${month}...`);
                            const monthResponse = await fetch(`data/${month}.json`);
                            if (!monthResponse.ok) {
                                console.warn(`Month data for ${month} not available or error: ${monthResponse.statusText}`);
                                continue;
                            }
                            
                            const monthData = await monthResponse.json();
                            loadedMonths[month] = monthData.rejectData || [];
                            console.log(`Successfully loaded ${loadedMonths[month].length} records for ${month}`);
                        } catch (error) {
                            console.warn(`Error loading data for ${month}:`, error);
                            continue;
                        }
                    } else {
                        console.log(`Using cached data for ${month} (${loadedMonths[month].length} records)`);
                    }
                    
                    // Add this month's data
                    rejectData = rejectData.concat(loadedMonths[month]);
                }
                
                console.log(`Total loaded records: ${rejectData.length}`);
                
                // Reset filters and build filter associations
                resetFilters();
                buildFilterAssociations();
                
                // Apply date filtering
                applyFilters();
                
                console.log(`After filtering: ${filteredData.length} records match criteria`);
                
                return true;
            } catch (error) {
                console.error('Error loading data for date range:', error);
                return false;
            }
        };
        
        // Build filter associations for interdependent filtering
        const buildFilterAssociations = function() {
            // Reset associations
            filterAssociations = {
                supervisor: {},
                product: {},
                variant: {},
                station: {},
                actionSelection: {}
            };
            
            // Process each reject item
            rejectData.forEach(item => {
                if (!item.ProductionDate) return;
                
                const itemDate = new Date(item.ProductionDate);
                // Check if this item is within date range
                if (!(itemDate >= currentFilters.dateFrom && itemDate <= currentFilters.dateTo)) {
                    return;
                }
                
                // Process supervisor associations
                if (item.LineSupervisor) {
                    if (!filterAssociations.supervisor[item.LineSupervisor]) {
                        filterAssociations.supervisor[item.LineSupervisor] = {
                            product: new Set(),
                            variant: new Set(),
                            station: new Set(),
                            actionSelection: new Set()
                        };
                    }
                    
                    if (item.Product) filterAssociations.supervisor[item.LineSupervisor].product.add(item.Product);
                    if (item.Variant) filterAssociations.supervisor[item.LineSupervisor].variant.add(item.Variant);
                    if (item.Station) filterAssociations.supervisor[item.LineSupervisor].station.add(item.Station);
                    if (item.ActionSelection) filterAssociations.supervisor[item.LineSupervisor].actionSelection.add(item.ActionSelection);
                }
                
                // Process product associations
                if (item.Product) {
                    if (!filterAssociations.product[item.Product]) {
                        filterAssociations.product[item.Product] = {
                            supervisor: new Set(),
                            variant: new Set(),
                            station: new Set(),
                            actionSelection: new Set()
                        };
                    }
                    
                    if (item.LineSupervisor) filterAssociations.product[item.Product].supervisor.add(item.LineSupervisor);
                    if (item.Variant) filterAssociations.product[item.Product].variant.add(item.Variant);
                    if (item.Station) filterAssociations.product[item.Product].station.add(item.Station);
                    if (item.ActionSelection) filterAssociations.product[item.Product].actionSelection.add(item.ActionSelection);
                }
                
                // Process variant associations
                if (item.Variant) {
                    if (!filterAssociations.variant[item.Variant]) {
                        filterAssociations.variant[item.Variant] = {
                            supervisor: new Set(),
                            product: new Set(),
                            station: new Set(),
                            actionSelection: new Set()
                        };
                    }
                    
                    if (item.LineSupervisor) filterAssociations.variant[item.Variant].supervisor.add(item.LineSupervisor);
                    if (item.Product) filterAssociations.variant[item.Variant].product.add(item.Product);
                    if (item.Station) filterAssociations.variant[item.Variant].station.add(item.Station);
                    if (item.ActionSelection) filterAssociations.variant[item.Variant].actionSelection.add(item.ActionSelection);
                }
                
                // Process station associations
                if (item.Station) {
                    if (!filterAssociations.station[item.Station]) {
                        filterAssociations.station[item.Station] = {
                            supervisor: new Set(),
                            product: new Set(),
                            variant: new Set(),
                            actionSelection: new Set()
                        };
                    }
                    
                    if (item.LineSupervisor) filterAssociations.station[item.Station].supervisor.add(item.LineSupervisor);
                    if (item.Product) filterAssociations.station[item.Station].product.add(item.Product);
                    if (item.Variant) filterAssociations.station[item.Station].variant.add(item.Variant);
                    if (item.ActionSelection) filterAssociations.station[item.Station].actionSelection.add(item.ActionSelection);
                }
                
                // Process ActionSelection associations
                if (item.ActionSelection) {
                    if (!filterAssociations.actionSelection[item.ActionSelection]) {
                        filterAssociations.actionSelection[item.ActionSelection] = {
                            supervisor: new Set(),
                            product: new Set(),
                            variant: new Set(),
                            station: new Set()
                        };
                    }
                    
                    if (item.LineSupervisor) filterAssociations.actionSelection[item.ActionSelection].supervisor.add(item.LineSupervisor);
                    if (item.Product) filterAssociations.actionSelection[item.ActionSelection].product.add(item.Product);
                    if (item.Variant) filterAssociations.actionSelection[item.ActionSelection].variant.add(item.Variant);
                    if (item.Station) filterAssociations.actionSelection[item.ActionSelection].station.add(item.Station);
                }
            });
            
            // Convert Sets to Arrays for easier use
            Object.keys(filterAssociations).forEach(filterType => {
                Object.keys(filterAssociations[filterType]).forEach(value => {
                    Object.keys(filterAssociations[filterType][value]).forEach(associatedType => {
                        filterAssociations[filterType][value][associatedType] = 
                            Array.from(filterAssociations[filterType][value][associatedType]);
                    });
                });
            });
        };
        
        // Get months between two dates (YYYY-MM format)
        const getMonthsInRange = function(startDate, endDate) {
            const months = [];
            const currentDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
            const endMonthDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0);
            
            while (currentDate <= endMonthDate) {
                const year = currentDate.getFullYear();
                const month = String(currentDate.getMonth() + 1).padStart(2, '0');
                const monthStr = `${year}-${month}`;
                
                if (indexData && indexData.availablePeriods && 
                    indexData.availablePeriods.includes(monthStr)) {
                    months.push(monthStr);
                }
                
                currentDate.setMonth(currentDate.getMonth() + 1);
            }
            
            return months;
        };
        
        // Apply filters to the data
        const applyFilters = function() {
            console.log("Applying filters with current state:", currentFilters);
            
            // First, filter by date range
            filteredData = rejectData.filter(item => {
                if (!item.ProductionDate) return false;
                const itemDate = new Date(item.ProductionDate);
                return itemDate >= currentFilters.dateFrom && 
                       itemDate <= currentFilters.dateTo;
            });
            
            console.log(`After date filtering: ${filteredData.length} records`);
            
            // Apply supervisor filter if any are selected
            if (currentFilters.supervisor && currentFilters.supervisor.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.LineSupervisor && currentFilters.supervisor.includes(item.LineSupervisor)
                );
                console.log(`After supervisor filtering: ${filteredData.length} records`);
            }
            
            // Apply product filter if any are selected
            if (currentFilters.product && currentFilters.product.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.Product && currentFilters.product.includes(item.Product)
                );
                console.log(`After product filtering: ${filteredData.length} records`);
            }
            
            // Apply variant filter if any are selected
            if (currentFilters.variant && currentFilters.variant.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.Variant && currentFilters.variant.includes(item.Variant)
                );
                console.log(`After variant filtering: ${filteredData.length} records`);
            }
            
            // Apply station filter if any are selected
            if (currentFilters.station && currentFilters.station.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.Station && currentFilters.station.includes(item.Station)
                );
                console.log(`After station filtering: ${filteredData.length} records`);
            }
            
            // Apply ActionSelection filter if any are selected
            if (currentFilters.actionSelection && currentFilters.actionSelection.length > 0) {
                filteredData = filteredData.filter(item => 
                    item.ActionSelection && currentFilters.actionSelection.includes(item.ActionSelection)
                );
                console.log(`After ActionSelection filtering: ${filteredData.length} records`);
            }
            
            return filteredData;
        };
        
        // Get available filter options based on current filter selections
        const getFilterOptions = function() {
            console.log("Getting filter options from", filteredData.length, "filtered records");
            
            // Initialize all options
            const options = {
                supervisor: new Set(),
                product: new Set(),
                variant: new Set(),
                station: new Set(),
                actionSelection: new Set()
            };
            
            // Process each record in the filtered data to extract unique values
            filteredData.forEach(item => {
                // Only add non-empty values
                if (item.LineSupervisor) options.supervisor.add(item.LineSupervisor);
                if (item.Product) options.product.add(item.Product);
                if (item.Variant) options.variant.add(item.Variant);
                if (item.Station) options.station.add(item.Station);
                if (item.ActionSelection) options.actionSelection.add(item.ActionSelection);
            });
            
            console.log("Extracted filter options:", 
                "Supervisors:", options.supervisor.size,
                "Products:", options.product.size,
                "Variants:", options.variant.size,
                "Stations:", options.station.size,
                "ActionSelections:", options.actionSelection.size
            );
            
            // Convert Sets to sorted arrays
            return {
                supervisor: Array.from(options.supervisor).sort(),
                product: Array.from(options.product).sort(),
                variant: Array.from(options.variant).sort(),
                station: Array.from(options.station).sort(),
                actionSelection: Array.from(options.actionSelection).sort()
            };
        };
        
        // Set table sort parameters
        const setTableSort = function(sortBy, sortDirection) {
            currentTableSort.sortBy = sortBy;
            currentTableSort.sortDirection = sortDirection;
            return true;
        };
        
        // Get current table sort parameters
        const getTableSort = function() {
            return currentTableSort;
        };
        
        // Update filter values
        const setFilter = function(filterName, values) {
            console.log(`Setting ${filterName} filter to:`, values);
            
            if (filterName in currentFilters) {
                currentFilters[filterName] = values;
                
                // Apply filters to get updated filtered data
                applyFilters();
                
                return true;
            }
            return false;
        };
        
        // Reset all filters except date range
        const resetFilters = function() {
            currentFilters.supervisor = [];
            currentFilters.product = [];
            currentFilters.variant = [];
            currentFilters.station = [];
            currentFilters.actionSelection = [];
            
            applyFilters();
            return true;
        };
        
        // Set date range filter
        const setDateRange = function(fromDate, toDate) {
            currentFilters.dateFrom = fromDate;
            currentFilters.dateTo = toDate;
            return true;
        };
        
        // Load comparison data
        const loadComparisonData = async function(period) {
            if (!currentFilters.dateFrom || !currentFilters.dateTo) {
                return false;
            }
            
            try {
                // Calculate comparison date range
                const comparisonRange = Utils.getComparisonDateRange(
                    currentFilters.dateFrom, 
                    currentFilters.dateTo,
                    period
                );
                
                if (!comparisonRange) {
                    comparisonData = null;
                    return false;
                }
                
                console.log("Loading comparison data for range:", 
                    comparisonRange.start.toISOString().split('T')[0], 
                    "to", 
                    comparisonRange.end.toISOString().split('T')[0]);
                
                // Get list of months needed
                const monthsToLoad = getMonthsInRange(
                    comparisonRange.start, 
                    comparisonRange.end
                );
                
                if (monthsToLoad.length === 0) {
                    console.warn('No comparison data available for selected period');
                    return false;
                }
                
                let tempData = [];
                
                // Load each required month
                for (const month of monthsToLoad) {
                    if (!loadedMonths[month]) {
                        try {
                            console.log(`Loading comparison data for ${month}...`);
                            const monthResponse = await fetch(`data/${month}.json`);
                            if (!monthResponse.ok) {
                                console.warn(`Month data for ${month} not available or error: ${monthResponse.statusText}`);
                                continue;
                            }
                            
                            const monthData = await monthResponse.json();
                            loadedMonths[month] = monthData.rejectData || [];
                        } catch (error) {
                            console.warn(`Error loading comparison data for ${month}:`, error);
                            continue;
                        }
                    }
                    
                    // Add this month's data
                    tempData = tempData.concat(loadedMonths[month]);
                }
                
                // Filter by date range
                comparisonData = tempData.filter(item => {
                    if (!item.ProductionDate) return false;
                    const itemDate = new Date(item.ProductionDate);
                    return itemDate >= comparisonRange.start && 
                           itemDate <= comparisonRange.end;
                });
                
                console.log(`Loaded ${comparisonData.length} comparison records`);
                
                return true;
            } catch (error) {
                console.error('Error loading comparison data:', error);
                comparisonData = null;
                return false;
            }
        };
        
        // Get currently filtered data
        const getFilteredData = function() {
            return filteredData;
        };
        
        // Get comparison data
        const getComparisonData = function() {
            return comparisonData;
        };
        
        // Get final inspection station data
        const getFinalInspectionData = function() {
            // Filter data for the Final Inspection stations
            const finalInspectionData = filteredData.filter(item => 
                item.Station && finalInspectionAliases.includes(item.Station)
            );
            
            return finalInspectionData;
        };
        
        // Get top rejects sorted by metric
        const getTopRejects = function(limit = 5, sortBy = 'qty', page = 1, pageSize = 5) {
            // Group data by station and reason
            const groupedData = {};
            
            // Calculate offset for pagination
            const offset = (page - 1) * pageSize;
            
            filteredData.forEach(item => {
                const key = `${item.Station || 'Unknown'}-${item.RejectReason || 'Unknown'}`;
                if (!groupedData[key]) {
                    // Get parts array
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts.filter(p => p && p.trim());
                    } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                    }
                    
                    groupedData[key] = {
                        station: item.Station || 'Unknown',
                        rejectReason: item.RejectReason || 'Unknown',
                        parts: new Set(parts),
                        partBatchNumbers: new Set(),
                        items: [item],
                        qty: 0,
                        cost: 0
                    };
                } else {
                    groupedData[key].items.push(item);
                    
                    // Add parts to the set
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts.filter(p => p && p.trim());
                        } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                    }
                    
                    parts.forEach(part => {
                        if (part) groupedData[key].parts.add(part);
                    });
                    
                    // Track batch numbers for RTS
                    if (item.PartBatchNumber) {
                        groupedData[key].partBatchNumbers.add(item.PartBatchNumber);
                    }
                }
                
                // Accumulate qty and cost
                groupedData[key].qty += (item.QTY || 0);
                groupedData[key].cost += (item.Cost || 0);
            });
            
            // Convert to array and sort
            let sortedData = Object.values(groupedData);
            
            // Apply table-specific sorting if needed
            if (currentTableSort.sortBy && currentTableSort.sortBy !== sortBy) {
                if (currentTableSort.sortBy === 'station') {
                    sortedData.sort((a, b) => {
                        return currentTableSort.sortDirection === 'asc' 
                            ? a.station.localeCompare(b.station)
                            : b.station.localeCompare(a.station);
                    });
                } else if (currentTableSort.sortBy === 'reason') {
                    sortedData.sort((a, b) => {
                        return currentTableSort.sortDirection === 'asc' 
                            ? a.rejectReason.localeCompare(b.rejectReason)
                            : b.rejectReason.localeCompare(a.rejectReason);
                    });
                } else if (currentTableSort.sortBy === 'qty') {
                    sortedData.sort((a, b) => {
                        return currentTableSort.sortDirection === 'asc' 
                            ? a.qty - b.qty
                            : b.qty - a.qty;
                    });
                } else if (currentTableSort.sortBy === 'cost') {
                    sortedData.sort((a, b) => {
                        return currentTableSort.sortDirection === 'asc' 
                            ? a.cost - b.cost
                            : b.cost - a.cost;
                    });
                }
            } else {
                if (sortBy === 'qty') {
                    sortedData.sort((a, b) => b.qty - a.qty);
                } else {
                    sortedData.sort((a, b) => b.cost - a.cost);
                }
            }
            
            // Format parts and batch numbers as comma-separated strings
            sortedData = sortedData.map(item => ({
                ...item,
                parts: Array.from(item.parts).join(', '),
                partBatchNumbers: Array.from(item.partBatchNumbers).join(', ')
            }));
            
            // Get total number of records
            const totalRecords = sortedData.length;
            
            // Calculate total pages
            const totalPages = Math.ceil(totalRecords / pageSize);
            
            // Apply pagination
            const paginatedData = sortedData.slice(offset, offset + pageSize);
            
            return {
                data: paginatedData,
                pagination: {
                    page,
                    pageSize,
                    totalRecords,
                    totalPages
                }
            };
        };
        
        // Get data for trend chart
        const getTrendChartData = function(sortBy = 'qty') {
            // Group by date and action type
            const dailyData = {};
            
            filteredData.forEach(item => {
                if (!item.ProductionDate) return;
                
                const date = item.ProductionDate;
                if (!dailyData[date]) {
                    dailyData[date] = { 
                        date, 
                        total: { qty: 0, cost: 0 },
                        Scrap: { qty: 0, cost: 0 },
                        RTS: { qty: 0, cost: 0 },
                        Local: { qty: 0, cost: 0 }
                    };
                }
                
                // Add to total
                dailyData[date].total.qty += (item.QTY || 0);
                dailyData[date].total.cost += (item.Cost || 0);
                
                // Add to specific action type
                const actionType = item.ActionSelection || 'Unknown';
                if (dailyData[date][actionType]) {
                    dailyData[date][actionType].qty += (item.QTY || 0);
                    dailyData[date][actionType].cost += (item.Cost || 0);
                }
            });
            
            // Convert to array and sort by date
            const trendData = Object.values(dailyData).sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            );
            
            // Get stats for trend lines (non-zero min, mean, max)
            const valueField = sortBy === 'qty' ? 'qty' : 'cost';
            const values = trendData.map(d => d.total[valueField]);
            const stats = Utils.calculateStats(values);
            
            return {
                data: trendData,
                stats
            };
        };
        
        // Get comparison data for trend chart
        const getComparisonTrendData = function(sortBy = 'qty') {
            if (!comparisonData) return null;
            
            // Group by date and action type
            const dailyData = {};
            
            comparisonData.forEach(item => {
                if (!item.ProductionDate) return;
                
                const date = item.ProductionDate;
                if (!dailyData[date]) {
                    dailyData[date] = { 
                        date, 
                        total: { qty: 0, cost: 0 },
                        Scrap: { qty: 0, cost: 0 },
                        RTS: { qty: 0, cost: 0 },
                        Local: { qty: 0, cost: 0 }
                    };
                }
                
                // Add to total
                dailyData[date].total.qty += (item.QTY || 0);
                dailyData[date].total.cost += (item.Cost || 0);
                
                // Add to specific action type
                const actionType = item.ActionSelection || 'Unknown';
                if (dailyData[date][actionType]) {
                    dailyData[date][actionType].qty += (item.QTY || 0);
                    dailyData[date][actionType].cost += (item.Cost || 0);
                }
            });
            
            // Convert to array and sort by date
            const trendData = Object.values(dailyData).sort((a, b) => 
                new Date(a.date) - new Date(b.date)
            );
            
            // Get stats for trend lines (non-zero min, mean, max)
            const valueField = sortBy === 'qty' ? 'qty' : 'cost';
            const values = trendData.map(d => d.total[valueField]);
            const stats = Utils.calculateStats(values);
            
            return {
                data: trendData,
                stats
            };
        };
        
        // Get top reject reasons data
        const getTopReasons = function(limit = 5, sortBy = 'qty') {
            // Group by reason
            const reasonsData = {};
            
            filteredData.forEach(item => {
                const reason = item.RejectReason || 'Unknown';
                
                if (!reasonsData[reason]) {
                    reasonsData[reason] = { 
                        reason, 
                        qty: 0, 
                        cost: 0,
                        products: new Set(),
                        stations: new Set()
                    };
                }
                
                reasonsData[reason].qty += (item.QTY || 0);
                reasonsData[reason].cost += (item.Cost || 0);
                
                if (item.Product) reasonsData[reason].products.add(item.Product);
                if (item.Station) reasonsData[reason].stations.add(item.Station);
            });
            
            // Convert to array and sort
            let sortedData = Object.values(reasonsData);
            
            if (sortBy === 'qty') {
                sortedData.sort((a, b) => b.qty - a.qty);
            } else {
                sortedData.sort((a, b) => b.cost - a.cost);
            }
            
            return sortedData.slice(0, limit);
        };
        
        // Get metrics summary
        const getMetricsSummary = function() {
            const totalQty = filteredData.reduce((sum, item) => sum + (item.QTY || 0), 0);
            const totalCost = filteredData.reduce((sum, item) => sum + (item.Cost || 0), 0);
            
            const scrapCount = filteredData
                .filter(item => item.ActionSelection === 'Scrap')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
                
            const rtsCount = filteredData
                .filter(item => item.ActionSelection === 'RTS')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
                
            const localCount = filteredData
                .filter(item => item.ActionSelection === 'Local')
                .reduce((sum, item) => sum + (item.QTY || 0), 0);
                
            const scrapPercent = totalQty > 0 ? Math.round((scrapCount / totalQty) * 100) : 0;
            const rtsPercent = totalQty > 0 ? Math.round((rtsCount / totalQty) * 100) : 0;
            const localPercent = totalQty > 0 ? Math.round((localCount / totalQty) * 100) : 0;
            
            let singlePartsCount = 0;
            let assembliesCount = 0;
            
            filteredData.forEach(item => {
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts.filter(p => p && p.trim());
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                }
                
                if (parts.length <= 1) {
                    singlePartsCount += (item.QTY || 0);
                } else {
                    assembliesCount += (item.QTY || 0);
                }
            });
            
            return {
                totalQty,
                totalCost,
                scrapCount,
                rtsCount,
                localCount,
                scrapPercent,
                rtsPercent,
                localPercent,
                singlePartsCount,
                assembliesCount
            };
        };
        
        // Get final inspection station reasons
        const getFinalInspectionReasons = function(sortBy = 'qty', page = 1, pageSize = 3) {
            // Get Final Inspection data
            const finalInspectionData = getFinalInspectionData();
            
            // Group data by reason
            const reasonsData = {};
            
            finalInspectionData.forEach(item => {
                const reason = item.RejectReason || 'Unknown';
                
                if (!reasonsData[reason]) {
                    // Initialize reason data
                    reasonsData[reason] = {
                        reason,
                        qty: 0,
                        cost: 0,
                        parts: new Set(),
                        items: []
                    };
                }
                
                // Add parts
                let parts = [];
                if (Array.isArray(item.Parts)) {
                    parts = item.Parts.filter(p => p && p.trim());
                } else if (typeof item.Parts === 'string') {
                    parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                }
                
                parts.forEach(part => {
                    if (part) reasonsData[reason].parts.add(part);
                });
                
                // Add this item
                reasonsData[reason].items.push(item);
                
                // Accumulate qty and cost
                reasonsData[reason].qty += (item.QTY || 0);
                reasonsData[reason].cost += (item.Cost || 0);
            });
            
            // Convert to array
            let reasonsArray = Object.values(reasonsData);
            
            // Sort by selected metric
            if (sortBy === 'qty') {
                reasonsArray.sort((a, b) => b.qty - a.qty);
            } else {
                reasonsArray.sort((a, b) => b.cost - a.cost);
            }
            
            // Format parts as comma-separated string
            reasonsArray = reasonsArray.map(item => ({
                ...item,
                parts: Array.from(item.parts).join(', ')
            }));
            
            // Calculate pagination
            const totalRecords = reasonsArray.length;
            const totalPages = Math.ceil(totalRecords / pageSize);
            const offset = (page - 1) * pageSize;
            
            // Apply pagination
            const paginatedData = reasonsArray.slice(offset, offset + pageSize);
            
            return {
                data: paginatedData,
                pagination: {
                    page,
                    pageSize,
                    totalRecords,
                    totalPages
                }
            };
        };
        
        // Get current filter values
        const getCurrentFilters = function() {
            return currentFilters;
        };
        
        // Get available action selections based on applied filters
        const getAvailableActionSelections = function() {
            // Start with all actions from the current date range
            const availableActions = new Set();
            
            // Determine which actions are available based on current filters
            let availableSet = null;
            
            // Check supervisor filter
            if (currentFilters.supervisor.length > 0) {
                const supervisorActions = new Set();
                currentFilters.supervisor.forEach(supervisor => {
                    if (filterAssociations.supervisor[supervisor] && 
                        filterAssociations.supervisor[supervisor].actionSelection) {
                        filterAssociations.supervisor[supervisor].actionSelection.forEach(action => {
                            supervisorActions.add(action);
                        });
                    }
                });
                
                if (!availableSet) {
                    availableSet = supervisorActions;
                } else {
                    // Intersect with previous set
                    availableSet = new Set([...availableSet].filter(action => supervisorActions.has(action)));
                }
            }
            
            // Check product filter
            if (currentFilters.product.length > 0) {
                const productActions = new Set();
                currentFilters.product.forEach(product => {
                    if (filterAssociations.product[product] && 
                        filterAssociations.product[product].actionSelection) {
                        filterAssociations.product[product].actionSelection.forEach(action => {
                            productActions.add(action);
                        });
                    }
                });
                
                if (!availableSet) {
                    availableSet = productActions;
                } else {
                    // Intersect with previous set
                    availableSet = new Set([...availableSet].filter(action => productActions.has(action)));
                }
            }
            
            // Check variant filter
            if (currentFilters.variant.length > 0) {
                const variantActions = new Set();
                currentFilters.variant.forEach(variant => {
                    if (filterAssociations.variant[variant] && 
                        filterAssociations.variant[variant].actionSelection) {
                        filterAssociations.variant[variant].actionSelection.forEach(action => {
                            variantActions.add(action);
                        });
                    }
                });
                
                if (!availableSet) {
                    availableSet = variantActions;
                } else {
                    // Intersect with previous set
                    availableSet = new Set([...availableSet].filter(action => variantActions.has(action)));
                }
            }
            
            // Check station filter
            if (currentFilters.station.length > 0) {
                const stationActions = new Set();
                currentFilters.station.forEach(station => {
                    if (filterAssociations.station[station] && 
                        filterAssociations.station[station].actionSelection) {
                        filterAssociations.station[station].actionSelection.forEach(action => {
                            stationActions.add(action);
                        });
                    }
                });
                
                if (!availableSet) {
                    availableSet = stationActions;
                } else {
                    // Intersect with previous set
                    availableSet = new Set([...availableSet].filter(action => stationActions.has(action)));
                }
            }
            
            // If no specific filters are applied, get all actions in date range
            if (!availableSet) {
                filteredData.forEach(item => {
                    if (item.ActionSelection) {
                        availableActions.add(item.ActionSelection);
                    }
                });
                
                return Array.from(availableActions).sort();
            }
            
            return Array.from(availableSet).sort();
        };
        
        // Get available stations for navigation
        const getAvailableStations = function() {
            const stations = new Set();
            
            // Get all stations from filtered data
            filteredData.forEach(item => {
                if (item.Station) {
                    stations.add(item.Station);
                }
            });
            
            // If any Final Inspection alias is included, exclude the individual aliases
            // and add a single "Final Inspection" entry
            let hasFinalInspection = false;
            finalInspectionAliases.forEach(alias => {
                if (stations.has(alias)) {
                    hasFinalInspection = true;
                    stations.delete(alias);
                }
            });
            
            if (hasFinalInspection) {
                stations.add('Final Inspection');
            }
            
            return Array.from(stations).sort();
        };
        
        // Set test data (for demo purposes)
        const setTestData = function(data) {
            rejectData = data;
            return true;
        };
        
        // Return public methods
        return {
            init,
            loadDataForDateRange,
            setFilter,
            resetFilters,
            setDateRange,
            loadComparisonData,
            getFilterOptions,
            getFilteredData,
            getComparisonData,
            getFinalInspectionData,
            getTopRejects,
            getTrendChartData,
            getComparisonTrendData,
            getTopReasons,
            getMetricsSummary,
            getFinalInspectionReasons,
            getCurrentFilters,
            getAvailableActionSelections,
            getAvailableStations,
            setTableSort,
            getTableSort,
            setTestData,
            finalInspectionAliases,
            stationGroups
        };
    })();
        /**
     * UI Module
     * Manages UI interactions and rendering
     */
    const UIModule = (function() {
        // Cache DOM elements
        const elements = {
            dateFrom: document.getElementById('date-from'),
            dateTo: document.getElementById('date-to'),
            applyDateBtn: document.getElementById('apply-date'),
            resetFiltersBtn: document.getElementById('reset-filters'),
            sortByQty: document.getElementById('sort-by-qty'),
            sortByCost: document.getElementById('sort-by-cost'),
            totalCost: document.getElementById('total-cost'),
            totalQty: document.getElementById('total-qty'),
            scrapPercent: document.getElementById('scrap-percent'),
            rtsPercent: document.getElementById('rts-percent'),
            localPercent: document.getElementById('local-percent'),
            scrapMetric: document.getElementById('scrap-metric'),
            rtsMetric: document.getElementById('rts-metric'),
            localMetric: document.getElementById('local-metric'),
            topRejectsBody: document.getElementById('top-rejects-body'),
            topRejectsEmpty: document.getElementById('top-rejects-empty'),
            topRejectsLoading: document.getElementById('top-rejects-loading'),
            topRejectsPaginationInfo: document.getElementById('top-rejects-pagination-info'),
            prevRejectsBtn: document.getElementById('prev-rejects'),
            nextRejectsBtn: document.getElementById('next-rejects'),
            // Final Inspection station elements
            finalInspectionQty: document.getElementById('final-inspection-qty'),
            finalInspectionCost: document.getElementById('final-inspection-cost'),
            stationReasonsContainer: document.getElementById('station-reasons-container'),
            stationReasonsPagination: document.getElementById('station-reasons-pagination'),
            prevStationBtn: document.getElementById('prev-station'),
            nextStationBtn: document.getElementById('next-station'),
            stationCurrent: document.getElementById('station-current'),
            stationTotal: document.getElementById('station-total'),
            // Trend chart elements
            trendViewQty: document.getElementById('trend-view-qty'),
            trendViewCost: document.getElementById('trend-view-cost'),
            comparisonPeriod: document.getElementById('comparison-period'),
            // Action selection toggle elements
            actionAll: document.getElementById('action-all'),
            actionScrap: document.getElementById('action-scrap'),
            actionRts: document.getElementById('action-rts'),
            actionLocal: document.getElementById('action-local')
        };
        
        // Current state
        let currentSortBy = 'qty'; // 'qty' or 'cost'
        let currentTopRejectsPage = 1;
        let currentStationPage = 1;
        let currentStationReasonsPage = 1;
        let currentTrendView = 'qty';
        let currentReasonsView = 'qty';
        let currentStationIndex = 0;
        let availableStations = [];
        
        // Initialize multiselect dropdowns
        const initMultiselect = function() {
            // Get all multiselect headers
            const headers = document.querySelectorAll('.multi-select-header');
            
            // Add click event to toggle dropdown
            headers.forEach(header => {
                header.addEventListener('click', (e) => {
                    e.stopPropagation();
                    
                    const multiSelect = header.closest('.multi-select');
                    const dropdown = multiSelect.querySelector('.multi-select-dropdown');
                    
                    // Close all other dropdowns first
                    document.querySelectorAll('.multi-select-dropdown.active').forEach(el => {
                        if (el !== dropdown) {
                            el.classList.remove('active');
                            el.style.display = 'none';
                        }
                    });
                    
                    // Toggle this dropdown
                    dropdown.classList.toggle('active');
                    
                    // Position dropdown if it's active
                    if (dropdown.classList.contains('active')) {
                        // Force display "block" for positioning calculations
                        dropdown.style.display = 'block';
                        positionDropdown(dropdown, header);
                    } else {
                        dropdown.style.display = 'none';
                    }
                });
            });
            
            // Close dropdowns when clicking outside
            document.addEventListener('click', () => {
                document.querySelectorAll('.multi-select-dropdown').forEach(dropdown => {
                    dropdown.classList.remove('active');
                    dropdown.style.display = 'none';
                });
            });
            
            // Prevent dropdown from closing when clicking inside it
            document.querySelectorAll('.multi-select-dropdown').forEach(dropdown => {
                dropdown.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            });
            
            // Search functionality for each dropdown
            document.querySelectorAll('.multi-select-search').forEach(search => {
                search.addEventListener('input', () => {
                    const searchTerm = search.value.toLowerCase();
                    const options = search.closest('.multi-select-dropdown')
                        .querySelectorAll('.multi-select-option');
                    
                    options.forEach(option => {
                        const text = option.textContent.toLowerCase();
                        if (text.includes(searchTerm)) {
                            option.style.display = '';
                        } else {
                            option.style.display = 'none';
                        }
                    });
                });
            });
            
            // Select All button
            document.querySelectorAll('.select-all-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const options = btn.closest('.multi-select-dropdown')
                        .querySelectorAll('.multi-select-option:not(.disabled) input[type="checkbox"]');
                    
                    options.forEach(checkbox => {
                        checkbox.checked = true;
                    });
                    
                    // Trigger change event on the first checkbox to update filter
                    if (options.length > 0) {
                        const event = new Event('change');
                        options[0].dispatchEvent(event);
                    }
                });
            });
            
            // Clear All button
            document.querySelectorAll('.clear-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    const options = btn.closest('.multi-select-dropdown')
                        .querySelectorAll('.multi-select-option input[type="checkbox"]');
                    
                    options.forEach(checkbox => {
                        checkbox.checked = false;
                    });
                    
                    // Trigger change event on the first checkbox to update filter
                    if (options.length > 0) {
                        const event = new Event('change');
                        options[0].dispatchEvent(event);
                    }
                });
            });
        };
        
        // Position dropdown relative to its header
        const positionDropdown = function(dropdown, header) {
            // Force display to enable calculations
            dropdown.style.display = 'block';
            
            const headerRect = header.getBoundingClientRect();
            const dropdownWidth = dropdown.offsetWidth;
            
            // Position directly below header, using fixed positioning
            dropdown.style.top = `${headerRect.bottom}px`;
            dropdown.style.left = `${headerRect.left}px`;
            
            // Ensure the dropdown doesn't go off-screen
            if (headerRect.left + dropdownWidth > window.innerWidth) {
                dropdown.style.left = `${window.innerWidth - dropdownWidth - 10}px`;
            }
            
            // Ensure the dropdown doesn't go off the bottom of the screen
            const dropdownHeight = dropdown.offsetHeight;
            if (headerRect.bottom + dropdownHeight > window.innerHeight) {
                dropdown.style.top = `${headerRect.top - dropdownHeight}px`;
            }
        };
        
        // Initialize table sorting functionality
        const initTableSorting = function() {
            document.querySelector('#top-rejects-table').addEventListener('click', function(e) {
                if (e.target.tagName === 'TH' && e.target.classList.contains('sortable')) {
                    const sortBy = e.target.dataset.sort;
                    const headerCells = document.querySelectorAll('#top-rejects-table th');
                    
                    // Remove existing sort classes
                    headerCells.forEach(cell => {
                        cell.classList.remove('sorted-asc', 'sorted-desc');
                    });
                    
                    // Determine sort direction
                    let sortDirection = 'asc';
                    if (e.target.classList.contains('sorted-asc')) {
                        sortDirection = 'desc';
                        e.target.classList.add('sorted-desc');
                    } else {
                        e.target.classList.add('sorted-asc');
                    }
                    
                    // Trigger sort event
                    triggerEvent('tableSortChanged', { 
                        sortBy, 
                        sortDirection 
                    });
                }
            });
        };
        
        // Initialize pagination controls
        const initPagination = function() {
            // Top Rejects pagination
            elements.prevRejectsBtn.addEventListener('click', () => {
                if (currentTopRejectsPage > 1) {
                    currentTopRejectsPage--;
                    triggerEvent('pageChanged', { 
                        type: 'topRejects', 
                        page: currentTopRejectsPage 
                    });
                }
            });
            
            elements.nextRejectsBtn.addEventListener('click', () => {
                currentTopRejectsPage++;
                triggerEvent('pageChanged', { 
                    type: 'topRejects', 
                    page: currentTopRejectsPage 
                });
            });
            
            // Station reasons pagination
            if (elements.stationReasonsPagination) {
                elements.stationReasonsPagination.addEventListener('click', (e) => {
                    if (e.target.classList.contains('station-page-btn')) {
                        const page = parseInt(e.target.dataset.page);
                        currentStationReasonsPage = page;
                        triggerEvent('pageChanged', { 
                            type: 'stationReasons', 
                            page: currentStationReasonsPage 
                        });
                    }
                });
            }
            
            // Station navigation
            elements.prevStationBtn.addEventListener('click', () => {
                if (currentStationIndex > 0) {
                    currentStationIndex--;
                    triggerEvent('stationChanged', { index: currentStationIndex });
                }
            });
            
            elements.nextStationBtn.addEventListener('click', () => {
                if (currentStationIndex < availableStations.length - 1) {
                    currentStationIndex++;
                    triggerEvent('stationChanged', { index: currentStationIndex });
                }
            });
        };
        
        // Initialize trend view toggles
        const initTrendToggles = function() {
            // Trend chart view toggle (qty/cost)
            elements.trendViewQty.addEventListener('click', () => {
                elements.trendViewQty.classList.add('active');
                elements.trendViewCost.classList.remove('active');
                currentTrendView = 'qty';
                triggerEvent('viewChanged', { type: 'trend', view: 'qty' });
            });
            
            elements.trendViewCost.addEventListener('click', () => {
                elements.trendViewQty.classList.remove('active');
                elements.trendViewCost.classList.add('active');
                currentTrendView = 'cost';
                triggerEvent('viewChanged', { type: 'trend', view: 'cost' });
            });
            
            // Reasons chart view toggle (qty/cost)
            elements.reasonsViewQty = document.getElementById('reasons-view-qty');
            elements.reasonsViewCost = document.getElementById('reasons-view-cost');
            
            if (elements.reasonsViewQty && elements.reasonsViewCost) {
                elements.reasonsViewQty.addEventListener('click', () => {
                    elements.reasonsViewQty.classList.add('active');
                    elements.reasonsViewCost.classList.remove('active');
                    currentReasonsView = 'qty';
                    triggerEvent('viewChanged', { type: 'reasons', view: 'qty' });
                });
                
                elements.reasonsViewCost.addEventListener('click', () => {
                    elements.reasonsViewQty.classList.remove('active');
                    elements.reasonsViewCost.classList.add('active');
                    currentReasonsView = 'cost';
                    triggerEvent('viewChanged', { type: 'reasons', view: 'cost' });
                });
            }
            
            // Comparison period selector
            elements.comparisonPeriod.addEventListener('change', () => {
                const period = elements.comparisonPeriod.value;
                triggerEvent('comparisonChanged', { period });
            });
        };
        
        // Initialize the UI module
        const init = function() {
            // Initialize multiselect dropdowns
            initMultiselect();
            
            // Initialize table sorting
            initTableSorting();
            
            // Initialize pagination controls
            initPagination();
            
            // Initialize trend view toggles
            initTrendToggles();
            
            // Set up main sort buttons
            document.getElementById('sort-by-qty').addEventListener('click', () => {
                setSortBy('qty');
            });
            
            document.getElementById('sort-by-cost').addEventListener('click', () => {
                setSortBy('cost');
            });
            
            document.getElementById('reset-filters').addEventListener('click', () => {
                triggerEvent('resetFilters');
            });
            
            document.getElementById('apply-date').addEventListener('click', () => {
                const fromDate = document.getElementById('date-from').value;
                const toDate = document.getElementById('date-to').value;
                
                if (fromDate && toDate) {
                    const fromDateObj = new Date(fromDate);
                    const toDateObj = new Date(toDate);
                    toDateObj.setHours(23, 59, 59, 999); // End of day
                    
                    triggerEvent('dateRangeChanged', { fromDate: fromDateObj, toDate: toDateObj });
                }
            });
            
            // Initialize ActionSelection toggle buttons
            document.getElementById('action-all').addEventListener('click', () => {
                setActionFilter('all');
            });
            
            document.getElementById('action-scrap').addEventListener('click', () => {
                setActionFilter('Scrap');
            });
            
            document.getElementById('action-rts').addEventListener('click', () => {
                setActionFilter('RTS');
            });
            
            document.getElementById('action-local').addEventListener('click', () => {
                setActionFilter('Local');
            });
            
            return true;
        };
        
        // Set sort by method (qty or cost)
        const setSortBy = function(sortBy) {
            if (sortBy === currentSortBy) return;
            
            currentSortBy = sortBy;
            
            // Update UI buttons
            document.getElementById('sort-by-qty').classList.toggle('active', sortBy === 'qty');
            document.getElementById('sort-by-cost').classList.toggle('active', sortBy === 'cost');
            
            // Trigger event to update charts and data
            triggerEvent('sortChanged', { sortBy });
        };
        
        // Set ActionSelection filter
        const setActionFilter = function(action) {
            // Update button states
            const buttons = document.querySelectorAll('.action-toggle-btn');
            buttons.forEach(btn => {
                btn.classList.remove('active');
            });
            
            let actionValues = [];
            if (action === 'all') {
                document.getElementById('action-all').classList.add('active');
                // Empty array means no filtering
            } else {
                document.getElementById(`action-${action.toLowerCase()}`).classList.add('active');
                actionValues = [action];
            }
            
            // Trigger filter change event
            triggerEvent('filterChanged', {
                type: 'actionSelection',
                values: actionValues
            });
        };
        
        // Create and populate multi-select options
        const populateMultiSelect = function(selectId, options, selectedValues = []) {
            console.log(`Populating ${selectId} with ${options.length} options`);
            
            const optionsContainer = document.getElementById(`${selectId.replace('-select', '')}-options`);
            if (!optionsContainer) {
                console.error(`Options container not found for ${selectId}`);
                return;
            }
            
            // Clear existing options
            optionsContainer.innerHTML = '';
            
            if (!options || options.length === 0) {
                const emptyOption = document.createElement('div');
                emptyOption.className = 'multi-select-option disabled';
                emptyOption.textContent = 'No options available';
                optionsContainer.appendChild(emptyOption);
                return;
            }
            
            // Add each option as a checkbox item
            options.forEach(option => {
                const optionDiv = document.createElement('div');
                optionDiv.className = 'multi-select-option';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.value = option;
                checkbox.checked = selectedValues.includes(option);
                checkbox.className = 'multi-select-checkbox';
                checkbox.id = `${selectId}-${option.toString().replace(/[^a-zA-Z0-9]/g, '-')}`;
                
                const label = document.createElement('label');
                label.textContent = option;
                label.htmlFor = checkbox.id;
                
                optionDiv.appendChild(checkbox);
                optionDiv.appendChild(label);
                optionsContainer.appendChild(optionDiv);
                
                // Add change event to checkbox
                checkbox.addEventListener('change', () => {
                    const filterType = selectId.replace('-select', '');
                    const allCheckboxes = optionsContainer.querySelectorAll('input[type="checkbox"]');
                    const selectedValues = Array.from(allCheckboxes)
                        .filter(cb => cb.checked)
                        .map(cb => cb.value);
                    
                    console.log(`${filterType} selection changed:`, selectedValues);
                    
                    // Update header text
                    updateMultiSelectHeader(selectId, selectedValues);
                    
                    // Trigger filter change event
                    triggerEvent('filterChanged', {
                        type: filterType,
                        values: selectedValues
                    });
                });
                
                // Make entire div clickable
                optionDiv.addEventListener('click', (e) => {
                    if (e.target !== checkbox) {
                        checkbox.checked = !checkbox.checked;
                        checkbox.dispatchEvent(new Event('change'));
                    }
                });
            });
            
            // Update header text
            updateMultiSelectHeader(selectId, selectedValues);
        };
        
        // Update multi-select header text
        const updateMultiSelectHeader = function(selectId, selectedValues) {
            const header = document.querySelector(`#${selectId} .multi-select-text`);
            if (!header) return;
            
            const filterType = selectId.replace('-select', '');
            const displayName = filterType.charAt(0).toUpperCase() + filterType.slice(1);
            
            if (selectedValues.length === 0) {
                header.textContent = `All ${displayName}s`;
            } else if (selectedValues.length === 1) {
                header.textContent = selectedValues[0];
            } else {
                header.textContent = `${selectedValues.length} ${displayName}s`;
            }
        };
        
        // Set date range inputs
        const setDateRange = function(fromDate, toDate) {
            if (fromDate) {
                document.getElementById('date-from').value = formatDateForInput(fromDate);
            }
            
            if (toDate) {
                document.getElementById('date-to').value = formatDateForInput(toDate);
            }
        };
        
        // Format date for input field
        const formatDateForInput = function(date) {
            if (!date) return '';
            
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            
            return `${year}-${month}-${day}`;
        };
        
        // Update metrics display
        const updateMetrics = function(metrics) {
            if (!metrics) return;
            
            document.getElementById('total-cost').textContent = Utils.formatCurrency(metrics.totalCost);
            document.getElementById('total-qty').textContent = metrics.totalQty.toLocaleString();
            
            document.getElementById('scrap-percent').textContent = `${metrics.scrapPercent}%`;
            document.getElementById('rts-percent').textContent = `${metrics.rtsPercent}%`;
            document.getElementById('local-percent').textContent = `${metrics.localPercent}%`;
            
            // Show/hide metrics based on data
            document.getElementById('scrap-metric').style.display = metrics.scrapCount > 0 ? '' : 'none';
            document.getElementById('rts-metric').style.display = metrics.rtsCount > 0 ? '' : 'none';
            document.getElementById('local-metric').style.display = metrics.localCount > 0 ? '' : 'none';
        };
        
        // Update top rejects table
        const updateTopRejectsTable = function(rejectsData, isRtsSelected) {
            const { data: rejects, pagination } = rejectsData;
            const tableBody = document.getElementById('top-rejects-body');
            if (!tableBody) return;
            
            tableBody.innerHTML = '';
            
            if (!rejects || rejects.length === 0) {
                document.getElementById('top-rejects-empty').style.display = 'flex';
                elements.prevRejectsBtn.disabled = true;
                elements.nextRejectsBtn.disabled = true;
                elements.topRejectsPaginationInfo.textContent = 'Showing 0-0 of 0';
                return;
            }
            
            document.getElementById('top-rejects-empty').style.display = 'none';
            
            // Update table header for RTS view (add PartBatchNumber column)
            const headerRow = document.querySelector('#top-rejects-table thead tr');
            if (headerRow) {
                // Check if PartBatchNumber column exists
                const batchHeader = headerRow.querySelector('th[data-sort="batch"]');
                
                if (isRtsSelected && !batchHeader) {
                    // Add batch number column for RTS view
                    const newHeader = document.createElement('th');
                    newHeader.textContent = 'Batch Number';
                    newHeader.dataset.sort = 'batch';
                    headerRow.insertBefore(newHeader, headerRow.querySelector('th[data-sort="qty"]'));
                } else if (!isRtsSelected && batchHeader) {
                    // Remove batch number column when not in RTS view
                    headerRow.removeChild(batchHeader);
                }
            }
            
            // Update pagination info
            const startItem = (pagination.page - 1) * pagination.pageSize + 1;
            const endItem = Math.min(startItem + rejects.length - 1, pagination.totalRecords);
            elements.topRejectsPaginationInfo.textContent = `Showing ${startItem}-${endItem} of ${pagination.totalRecords}`;
            
            // Update pagination buttons
            elements.prevRejectsBtn.disabled = pagination.page <= 1;
            elements.nextRejectsBtn.disabled = pagination.page >= pagination.totalPages;
            
            // Add data rows
            rejects.forEach(reject => {
                const row = document.createElement('tr');
                
                // Create cells with truncated text where needed
                const stationCell = document.createElement('td');
                stationCell.title = reject.station;
                stationCell.textContent = Utils.truncateText(reject.station, 30);
                
                const partsCell = document.createElement('td');
                partsCell.title = reject.parts;
                partsCell.textContent = Utils.truncateText(reject.parts, 40);
                
                const reasonCell = document.createElement('td');
                reasonCell.title = reject.rejectReason;
                reasonCell.textContent = Utils.truncateText(reject.rejectReason, 30);
                
                const qtyCell = document.createElement('td');
                qtyCell.textContent = reject.qty;
                
                const costCell = document.createElement('td');
                costCell.textContent = Utils.formatCurrency(reject.cost);
                
                // Add cells to row
                row.appendChild(stationCell);
                row.appendChild(partsCell);
                row.appendChild(reasonCell);
                
                // Add batch number cell if RTS is selected
                if (isRtsSelected) {
                    const batchCell = document.createElement('td');
                    batchCell.title = reject.partBatchNumbers;
                    batchCell.textContent = Utils.truncateText(reject.partBatchNumbers, 30);
                    row.appendChild(batchCell);
                }
                
                row.appendChild(qtyCell);
                row.appendChild(costCell);
                
                // Add row to table
                tableBody.appendChild(row);
            });
        };
        
        // Update final inspection station card
        const updateFinalInspectionCard = function(reasonsData, stationData, stationsList) {
            const { data: reasons, pagination } = reasonsData;
            
            // Update metrics
            if (elements.finalInspectionQty) {
                elements.finalInspectionQty.textContent = stationData.qty.toLocaleString();
            }
            
            if (elements.finalInspectionCost) {
                elements.finalInspectionCost.textContent = Utils.formatCurrency(stationData.cost);
            }
            
            // Update reasons list
            if (elements.stationReasonsContainer) {
                elements.stationReasonsContainer.innerHTML = '';
                
                if (reasons && reasons.length > 0) {
                    reasons.forEach(reason => {
                        const reasonItem = document.createElement('div');
                        reasonItem.className = 'reason-item';
                        
                        const reasonInfo = document.createElement('div');
                        reasonInfo.className = 'reason-info';
                        
                        const reasonName = document.createElement('div');
                        reasonName.className = 'reason-name';
                        reasonName.title = reason.reason;
                        reasonName.textContent = Utils.truncateText(reason.reason, 20);
                        
                        const reasonParts = document.createElement('div');
                        reasonParts.className = 'reason-parts';
                        reasonParts.title = reason.parts;
                        reasonParts.textContent = `Parts: ${Utils.truncateText(reason.parts, 30)}`;
                        reasonParts.style.fontSize = '0.75rem';
                        reasonParts.style.color = 'var(--text-muted)';
                        
                        reasonInfo.appendChild(reasonName);
                        reasonInfo.appendChild(reasonParts);
                        
                        const reasonValue = document.createElement('div');
                        reasonValue.className = 'reason-value';
                        reasonValue.title = `Qty: ${reason.qty}, Cost: ${Utils.formatCurrency(reason.cost)}`;
                        reasonValue.textContent = `${reason.qty} (${Utils.formatCurrency(reason.cost)})`;
                        
                        reasonItem.appendChild(reasonInfo);
                        reasonItem.appendChild(reasonValue);
                        
                        elements.stationReasonsContainer.appendChild(reasonItem);
                    });
                } else {
                    const emptyReasons = document.createElement('div');
                    emptyReasons.className = 'empty-text';
                    emptyReasons.textContent = 'No reasons data available';
                    elements.stationReasonsContainer.appendChild(emptyReasons);
                }
            }
            
            // Update reasons pagination
            if (elements.stationReasonsPagination) {
                elements.stationReasonsPagination.innerHTML = '';
                
                if (pagination && pagination.totalPages > 1) {
                    for (let i = 1; i <= pagination.totalPages; i++) {
                        const pageBtn = document.createElement('button');
                        pageBtn.className = `station-page-btn ${i === pagination.page ? 'active' : ''}`;
                        pageBtn.dataset.page = i;
                        pageBtn.textContent = i;
                        elements.stationReasonsPagination.appendChild(pageBtn);
                    }
                }
            }
            
            // Update station navigation
            availableStations = stationsList;
            
            if (elements.stationCurrent && elements.stationTotal) {
                elements.stationCurrent.textContent = currentStationIndex + 1;
                elements.stationTotal.textContent = availableStations.length;
            }
            
            if (elements.prevStationBtn && elements.nextStationBtn) {
                elements.prevStationBtn.disabled = currentStationIndex <= 0;
                elements.nextStationBtn.disabled = currentStationIndex >= availableStations.length - 1;
            }
            
            // Update station title
            const stationTitleElement = document.querySelector('#final-inspection-card .station-card-title span');
            if (stationTitleElement && availableStations[currentStationIndex]) {
                stationTitleElement.textContent = availableStations[currentStationIndex];
            }
        };
        
        // Get current sort method
        const getCurrentSortBy = function() {
            return currentSortBy;
        };
        
        // Get current trend view (qty or cost)
        const getCurrentTrendView = function() {
            return currentTrendView;
        };
        
        // Get current reasons view (qty or cost)
        const getCurrentReasonsView = function() {
            return currentReasonsView;
        };
        
        // Get current top rejects page
        const getCurrentTopRejectsPage = function() {
            return currentTopRejectsPage;
        };
        
        // Get current station index
        const getCurrentStationIndex = function() {
            return currentStationIndex;
        };
        
        // Set current station index
        const setCurrentStationIndex = function(index) {
            currentStationIndex = index;
        };
        
        // Get current station reasons page
        const getCurrentStationReasonsPage = function() {
            return currentStationReasonsPage;
        };
        
        // Get selected comparison period
        const getSelectedComparisonPeriod = function() {
            return elements.comparisonPeriod.value;
        };
        
        // Update ActionSelection toggle button states
        const updateActionSelectionButtons = function(availableActions) {
            // Check if we have action types available
            const hasScrap = availableActions.includes('Scrap');
            const hasRts = availableActions.includes('RTS');
            const hasLocal = availableActions.includes('Local');
            
            // Show/hide buttons based on available data
            document.getElementById('action-scrap').style.display = hasScrap ? '' : 'none';
            document.getElementById('action-rts').style.display = hasRts ? '' : 'none';
            document.getElementById('action-local').style.display = hasLocal ? '' : 'none';
            
            // If none are available, hide the entire section
            const actionToggle = document.getElementById('action-toggle');
            if (actionToggle) {
                if (availableActions.length === 0) {
                    actionToggle.parentElement.style.display = 'none';
                } else {
                    actionToggle.parentElement.style.display = '';
                }
            }
        };
        
        // Reset pagination
        const resetPagination = function() {
            currentTopRejectsPage = 1;
            currentStationReasonsPage = 1;
        };
        
        // Trigger a custom event
        const triggerEvent = function(name, detail = {}) {
            const event = new CustomEvent(name, { detail });
            document.dispatchEvent(event);
        };
        
        // Return public methods
        return {
            init,
            getElements: function() { return elements; }, // NEW: Expose elements
            setSortBy,
            setActionFilter,
            populateMultiSelect,
            setDateRange,
            updateMetrics,
            updateTopRejectsTable,
            updateFinalInspectionCard,
            updateActionSelectionButtons,
            resetPagination,
            getCurrentSortBy,
            getCurrentTrendView,
            getCurrentReasonsView,
            getCurrentTopRejectsPage,
            getCurrentStationIndex,
            setCurrentStationIndex,
            getCurrentStationReasonsPage,
            getSelectedComparisonPeriod,
            triggerEvent
        };
    })();
        /**
     * Chart Module
     * Creates and updates data visualizations
     */
    const ChartModule = (function() {
        // Create trend chart with improved sizing and visibility
        const createTrendChart = function(data, comparisonData = null, sortBy = 'qty') {
            const container = document.getElementById('trend-chart-container');
            if (!container || !data || !data.data || data.data.length === 0) {
                const emptyElement = document.getElementById('trend-chart-empty');
                if (emptyElement) emptyElement.style.display = 'flex';
                return;
            }
            
            // Hide empty state
            const emptyElement = document.getElementById('trend-chart-empty');
            if (emptyElement) emptyElement.style.display = 'none';
            
            // Clear previous chart
            container.innerHTML = '';
            
            // Set dimensions - use the container size
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Adjust margins to reduce whitespace but ensure labels are visible
            const margin = { top: 15, right: 15, bottom: 35, left: 50 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Create SVG container with proper viewBox for responsiveness
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet')
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Process data for stacked bars
            const trendData = data.data;
            
            // Create scales
            const xScale = d3.scaleBand()
                .domain(trendData.map(d => d.date))
                .range([0, chartWidth])
                .padding(0.2);
            
            // Determine max value for Y scale
            let yMax = 0;
            
            if (sortBy === 'qty') {
                yMax = d3.max(trendData, d => d.total.qty);
                if (comparisonData && comparisonData.data) {
                    const compMax = d3.max(comparisonData.data, d => d.total.qty);
                    yMax = Math.max(yMax, compMax);
                }
            } else {
                yMax = d3.max(trendData, d => d.total.cost);
                if (comparisonData && comparisonData.data) {
                    const compMax = d3.max(comparisonData.data, d => d.total.cost);
                    yMax = Math.max(yMax, compMax);
                }
            }
            
            // Add padding to yMax
            yMax = yMax * 1.1;
            
            const yScale = d3.scaleLinear()
                .domain([0, yMax])
                .range([chartHeight, 0]);
            
            // Add X axis - make tick labels dynamic based on available width
            const tickValues = xScale.domain().filter((d, i) => {
                // Create ticker algorithm based on available width
                const numOfDays = trendData.length;
                const spacing = Math.max(1, Math.floor(numOfDays / Math.min(10, Math.floor(chartWidth / 50))));
                return i % spacing === 0;
            });
            
            const xAxis = svg.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale)
                    .tickFormat(d => {
                        const date = new Date(d);
                        return date.getDate().toString();
                    })
                    .tickValues(tickValues)
                );
            
            // Add X axis label
            svg.append('text')
                .attr('transform', `translate(${chartWidth/2},${chartHeight + margin.bottom - 5})`)
                .style('text-anchor', 'middle')
                .style('font-size', '10px')
                .text('Day of Month');
            
            // Add Y axis with more readable ticks
            svg.append('g')
                .call(d3.axisLeft(yScale)
                    .ticks(Math.min(5, Math.floor(chartHeight / 30))) // Adjust ticks based on height
                    .tickFormat(d => sortBy === 'cost' ? `R${d}` : d));
            
            // Add Y axis label
            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('y', -margin.left + 10)
                .attr('x', -chartHeight / 2)
                .attr('dy', '1em')
                .style('text-anchor', 'middle')
                .style('font-size', '10px')
                .text(sortBy === 'qty' ? 'Quantity' : 'Cost (R)');
            
            // Add light grid lines to improve readability
            svg.append('g')
                .attr('class', 'grid')
                .selectAll('line')
                .data(yScale.ticks(5))
                .enter()
                .append('line')
                .attr('x1', 0)
                .attr('x2', chartWidth)
                .attr('y1', d => yScale(d))
                .attr('y2', d => yScale(d))
                .attr('stroke', '#e0e0e0')
                .attr('stroke-width', 0.5);

            // Define action types and colors
            const actionTypes = ['Scrap', 'RTS', 'Local'];
            const colors = {
                'Scrap': 'var(--scrap-color)',
                'RTS': 'var(--rts-color)',
                'Local': 'var(--local-color)'
            };
            
            // Create stacked bars for each action type with improved positioning
            actionTypes.forEach((action, i) => {
                svg.selectAll(`.bar-${action}`)
                    .data(trendData)
                    .enter()
                    .append('rect')
                    .attr('class', `bar-${action}`)
                    .attr('x', d => {
                        const baseX = xScale(d.date);
                        const segmentWidth = xScale.bandwidth() / actionTypes.length;
                        return baseX + i * segmentWidth;
                    })
                    .attr('width', xScale.bandwidth() / actionTypes.length)
                    .attr('y', d => {
                        const value = sortBy === 'qty' ? d[action].qty : d[action].cost;
                        return yScale(value);
                    })
                    .attr('height', d => {
                        const value = sortBy === 'qty' ? d[action].qty : d[action].cost;
                        return chartHeight - yScale(value);
                    })
                    .attr('fill', colors[action])
                    .attr('opacity', 0.8)
                    .on('mouseover', function(event, d) {
                        // Enhanced tooltip
                        d3.select(this).attr('opacity', 1);
                        
                        const tooltip = d3.select('body')
                            .append('div')
                            .attr('class', 'tooltip')
                            .style('opacity', 0);
                        
                        tooltip.transition()
                            .duration(200)
                            .style('opacity', 0.9);
                        
                        tooltip.html(`
                            <div style="font-weight:bold;margin-bottom:4px">
                                ${Utils.formatDateForDisplay(d.date)} - ${action}
                            </div>
                            <div>Quantity: <strong>${d[action].qty}</strong></div>
                            <div>Cost: <strong>${Utils.formatCurrency(d[action].cost)}</strong></div>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', function() {
                        d3.select(this).attr('opacity', 0.8);
                        d3.selectAll('.tooltip').remove();
                    });
            });
            
            // Add trend lines (min, mean, max)
            if (data.stats) {
                // Max trend line
                svg.append('line')
                    .attr('x1', 0)
                    .attr('x2', chartWidth)
                    .attr('y1', yScale(data.stats.max))
                    .attr('y2', yScale(data.stats.max))
                    .attr('stroke', 'var(--danger-color)')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                // Mean trend line
                svg.append('line')
                    .attr('x1', 0)
                    .attr('x2', chartWidth)
                    .attr('y1', yScale(data.stats.mean))
                    .attr('y2', yScale(data.stats.mean))
                    .attr('stroke', 'var(--warning-color)')
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '5,5');
                
                // Min (non-zero) trend line
                if (data.stats.min > 0) {
                    svg.append('line')
                        .attr('x1', 0)
                        .attr('x2', chartWidth)
                        .attr('y1', yScale(data.stats.min))
                        .attr('y2', yScale(data.stats.min))
                        .attr('stroke', 'var(--success-color)')
                        .attr('stroke-width', 2)
                        .attr('stroke-dasharray', '5,5');
                }
                
                // Add labels for trend lines with more compact presentation
                svg.append('text')
                    .attr('x', 5)
                    .attr('y', yScale(data.stats.max) - 5)
                    .attr('font-size', '10px')
                    .attr('fill', 'var(--danger-color)')
                    .text(`Max: ${sortBy === 'qty' ? data.stats.max : Utils.formatCurrency(data.stats.max)}`);
                
                svg.append('text')
                    .attr('x', 5)
                    .attr('y', yScale(data.stats.mean) - 5)
                    .attr('font-size', '10px')
                    .attr('fill', 'var(--warning-color)')
                    .text(`Mean: ${sortBy === 'qty' ? Math.round(data.stats.mean) : Utils.formatCurrency(data.stats.mean)}`);
                
                if (data.stats.min > 0) {
                    svg.append('text')
                        .attr('x', 5)
                        .attr('y', yScale(data.stats.min) - 5)
                        .attr('font-size', '10px')
                        .attr('fill', 'var(--success-color)')
                        .text(`Min: ${sortBy === 'qty' ? data.stats.min : Utils.formatCurrency(data.stats.min)}`);
                }
            }
            
            // Add comparison line if data is available
            if (comparisonData && comparisonData.data && comparisonData.data.length > 0) {
                // Create a line for comparison data
                const compData = comparisonData.data;
                
                // Create a line function
                const compLine = d3.line()
                    .x((d, i) => {
                        // Handle mapping comparison dates to current dates
                        return xScale(trendData[Math.min(i, trendData.length - 1)].date) + xScale.bandwidth() / 2;
                    })
                    .y(d => {
                        const value = sortBy === 'qty' ? d.total.qty : d.total.cost;
                        return yScale(value);
                    })
                    .curve(d3.curveMonotoneX);
                
                // Add the comparison line
                svg.append('path')
                    .datum(compData.slice(0, trendData.length)) // Use only as many points as in current data
                    .attr('fill', 'none')
                    .attr('stroke', '#9b59b6') // Purple for comparison
                    .attr('stroke-width', 2)
                    .attr('stroke-dasharray', '3,3')
                    .attr('d', compLine);
                
                // Add data points on the comparison line
                svg.selectAll('.comp-point')
                    .data(compData.slice(0, trendData.length))
                    .enter()
                    .append('circle')
                    .attr('class', 'comp-point')
                    .attr('cx', (d, i) => xScale(trendData[Math.min(i, trendData.length - 1)].date) + xScale.bandwidth() / 2)
                    .attr('cy', d => {
                        const value = sortBy === 'qty' ? d.total.qty : d.total.cost;
                        return yScale(value);
                    })
                    .attr('r', 3)
                    .attr('fill', 'white')
                    .attr('stroke', '#9b59b6')
                    .attr('stroke-width', 1.5)
                    .on('mouseover', function(event, d) {
                        // Enhanced tooltip for comparison points
                        const tooltip = d3.select('body')
                            .append('div')
                            .attr('class', 'tooltip')
                            .style('opacity', 0);
                        
                        tooltip.transition()
                            .duration(200)
                            .style('opacity', 0.9);
                        
                        tooltip.html(`
                            <div style="font-weight:bold;margin-bottom:4px">
                                Comparison: ${Utils.formatDateForDisplay(d.date)}
                            </div>
                            <div>Quantity: <strong>${d.total.qty}</strong></div>
                            <div>Cost: <strong>${Utils.formatCurrency(d.total.cost)}</strong></div>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', function() {
                        d3.selectAll('.tooltip').remove();
                    });
            }
        };
        
        // Create reasons chart with improved visibility
        const createReasonsChart = function(data, sortBy = 'qty') {
            const container = document.getElementById('reasons-chart-container');
            if (!container || !data || data.length === 0) {
                const emptyElement = document.getElementById('reasons-chart-empty');
                if (emptyElement) emptyElement.style.display = 'flex';
                return;
            }
            
            // Hide empty state
            const emptyElement = document.getElementById('reasons-chart-empty');
            if (emptyElement) emptyElement.style.display = 'none';
            
            // Clear previous chart
            container.innerHTML = '';
            
            // Set dimensions - use container size
            const width = container.clientWidth;
            const height = container.clientHeight;
            
            // Adjust margins to reduce whitespace but ensure labels are visible
            const margin = { top: 10, right: 60, bottom: 20, left: 120 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Sort data
            data.sort((a, b) => {
                if (sortBy === 'qty') {
                    return b.qty - a.qty;
                } else {
                    return b.cost - a.cost;
                }
            });
            
            // Limit to top 5 reasons
            data = data.slice(0, 5);
            
            // Create SVG container with responsive viewBox
            const svg = d3.select(container)
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .attr('viewBox', `0 0 ${width} ${height}`)
                .attr('preserveAspectRatio', 'xMidYMid meet')
                .append('g')
                .attr('transform', `translate(${margin.left},${margin.top})`);
            
            // Create scales
            const yScale = d3.scaleBand()
                .domain(data.map(d => d.reason))
                .range([0, chartHeight])
                .padding(0.2);
            
            const xValue = d => sortBy === 'qty' ? d.qty : d.cost;
            const xMax = d3.max(data, xValue);
            
            const xScale = d3.scaleLinear()
                .domain([0, xMax * 1.1]) // Add 10% padding
                .range([0, chartWidth]);
            
            // Add Y axis with truncated text for better fit
            svg.append('g')
                .call(d3.axisLeft(yScale)
                    .tickFormat(d => Utils.truncateText(d, 15)));
            
            // Add X axis with fewer ticks for clarity
            svg.append('g')
                .attr('transform', `translate(0,${chartHeight})`)
                .call(d3.axisBottom(xScale)
                    .ticks(Math.min(5, Math.floor(chartWidth / 50)))
                    .tickFormat(d => sortBy === 'cost' ? `R${d}` : d));
            
            // Create color scale for bars
            const colors = ['#3498db', '#e74c3c', '#2ecc71', '#f39c12', '#9b59b6'];
            
            // Add bars with enhanced styling
            svg.selectAll('.bar')
                .data(data)
                .enter()
                .append('rect')
                .attr('class', 'bar')
                .attr('y', d => yScale(d.reason))
                .attr('height', yScale.bandwidth())
                .attr('x', 0)
                .attr('width', d => xScale(xValue(d)))
                .attr('fill', (d, i) => colors[i % colors.length])
                .attr('rx', 2) // Rounded corners
                .on('mouseover', function(event, d) {
                    // Enhanced tooltip
                    d3.select(this)
                        .attr('opacity', 0.8)
                        .attr('stroke', '#333')
                        .attr('stroke-width', 1);
                    
                    const tooltip = d3.select('body')
                        .append('div')
                        .attr('class', 'tooltip')
                        .style('opacity', 0);
                    
                    tooltip.transition()
                        .duration(200)
                        .style('opacity', 0.9);
                    
                    // Format stations list
                    const stations = Array.from(d.stations || [])
                        .slice(0, 3)
                        .join(', ');
                    const stationsText = d.stations && d.stations.size > 3 
                        ? `${stations}... (${d.stations.size - 3} more)`
                        : stations;
                    
                    // Format products list
                    const products = Array.from(d.products || [])
                        .slice(0, 3)
                        .join(', ');
                    const productsText = d.products && d.products.size > 3 
                        ? `${products}... (${d.products.size - 3} more)`
                        : products;
                    
                    tooltip.html(`
                        <div style="font-weight:bold;border-bottom:1px solid #eee;padding-bottom:4px;margin-bottom:4px">
                            ${d.reason}
                        </div>
                        <div>Quantity: <strong>${d.qty}</strong></div>
                        <div>Cost: <strong>${Utils.formatCurrency(d.cost)}</strong></div>
                        <div>Stations: ${stationsText || 'N/A'}</div>
                        <div>Products: ${productsText || 'N/A'}</div>
                    `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 28) + 'px');
                })
                .on('mouseout', function() {
                    d3.select(this)
                        .attr('opacity', 1)
                        .attr('stroke', 'none');
                    
                    d3.selectAll('.tooltip').remove();
                });
            
            // Add value labels with better positioning
            svg.selectAll('.bar-label')
                .data(data)
                .enter()
                .append('text')
                .attr('class', 'bar-label')
                .attr('y', d => yScale(d.reason) + yScale.bandwidth() / 2 + 4)
                .attr('x', d => xScale(xValue(d)) + 5)
                .text(d => {
                    const value = sortBy === 'qty' ? d.qty : Utils.formatCurrency(d.cost);
                    // Keep label short to avoid overflow
                    return value;
                })
                .attr('font-size', '10px')
                .attr('fill', '#333');
        };
        
        // Return public methods
        return {
            createTrendChart,
            createReasonsChart
        };
    })();
        /**
     * Dashboard Module
     * Orchestrates the overall application
     */
    const DashboardModule = (function() {
        // Add reference to UI elements
        let elements;
        let currentStationIndex = 0;
        let availableStations = [];

        // Initialize the dashboard
        const init = async function() {
            try {
                console.log("Initializing dashboard...");
                
                // Initialize UI
                UIModule.init();
                
                // Get reference to UI elements
                elements = UIModule.getElements();
                
                // Initialize data module
                await DataModule.init();
                
                // Set up event listeners
                setupEventListeners();
                
                // Load initial data - modified to auto-load last 5 dates
                await loadInitialData();
                
                console.log("Dashboard initialization complete");
                return true;
            } catch (error) {
                console.error('Error initializing dashboard:', error);
                return false;
            }
        };
        
        // Set up event listeners
        const setupEventListeners = function() {
            // Date range changed
            document.addEventListener('dateRangeChanged', async (e) => {
                const { fromDate, toDate } = e.detail;
                
                // Update data module with new date range
                DataModule.setDateRange(fromDate, toDate);
                
                // Reload data for new date range
                await loadDataForDateRange();
            });
            
            // Table sort changed
            document.addEventListener('tableSortChanged', (e) => {
                const { sortBy, sortDirection } = e.detail;
                
                // Update data module with sort parameters
                DataModule.setTableSort(sortBy, sortDirection);
                
                // Update just the top rejects table
                updateTopRejectsTable();
            });
            
            // Load data for current date range
            document.addEventListener('filterChanged', (e) => {
                const { type, values } = e.detail;
                
                console.log(`Filter changed: ${type}`, values);
                
                // Update data module with new filter values
                DataModule.setFilter(type, values);
                
                // Get updated filter options based on current selections
                const filterOptions = DataModule.getFilterOptions();
                
                // Update UI with available options for other filters
                Object.keys(filterOptions).forEach(filterType => {
                    if (filterType !== type && filterType !== 'actionSelection') {
                        const currentFilters = DataModule.getCurrentFilters();
                        const selectedValues = currentFilters[filterType] || [];
                        
                        UIModule.populateMultiSelect(`${filterType}-select`, filterOptions[filterType], selectedValues);
                    }
                });
                
                // Get available action selections based on applied filters
                const availableActions = DataModule.getAvailableActionSelections();
                UIModule.updateActionSelectionButtons(availableActions);
                
                // Reset pagination
                UIModule.resetPagination();
                
                // Update dashboard with filtered data
                updateDashboard();
            });
            
            // Reset filters
            document.addEventListener('resetFilters', () => {
                // Reset filters in data module
                DataModule.resetFilters();
                
                // Update UI with all options
                const filterOptions = DataModule.getFilterOptions();
                
                Object.keys(filterOptions).forEach(filterType => {
                    if (filterType !== 'actionSelection') {
                        UIModule.populateMultiSelect(`${filterType}-select`, filterOptions[filterType], []);
                    }
                });
                
                // Reset action selection buttons
                document.querySelectorAll('.action-toggle-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById('action-all').classList.add('active');
                
                // Reset pagination
                UIModule.resetPagination();
                
                // Update dashboard with filtered data
                updateDashboard();
            });
            
            // Sort method changed
            document.addEventListener('sortChanged', (e) => {
                const { sortBy } = e.detail;
                
                // Update dashboard with new sort method
                updateDashboard(sortBy);
            });
            
            // Page changed
            document.addEventListener('pageChanged', (e) => {
                const { type, page } = e.detail;
                
                // Update dashboard with new page
                updateDashboard();
            });
            
            // Station changed
            document.addEventListener('stationChanged', (e) => {
                const { index } = e.detail;
                
                // Update dashboard with new station
                updateDashboard();
            });
            
            // View changed (trend or reasons)
            document.addEventListener('viewChanged', (e) => {
                const { type, view } = e.detail;
                
                // Update only the specific chart
                if (type === 'trend') {
                    updateTrendChart();
                } else if (type === 'reasons') {
                    updateReasonsChart();
                }
            });
            
            // Comparison period changed
            document.addEventListener('comparisonChanged', async (e) => {
                const { period } = e.detail;
                
                if (period === 'none') {
                    // No comparison needed
                    updateTrendChart();
                } else {
                    // Load comparison data
                    await loadComparisonData(period);
                }
            });
        };
        
        // Load initial data - modified to auto-load last 5 dates with reject data
        const loadInitialData = async function() {
            try {
                console.log("Loading initial data...");
                
                // Show loading state
                document.getElementById('top-rejects-loading').style.display = 'flex';
                document.getElementById('trend-chart-loading').style.display = 'flex';
                document.getElementById('reasons-chart-loading').style.display = 'flex';
                
                // Get the available periods from the index data
                const indexResponse = await fetch('RejectsIndex.json');
                if (!indexResponse.ok) {
                    throw new Error('Failed to load index data');
                }
                
                const indexData = await indexResponse.json();
                const availablePeriods = indexData.availablePeriods || [];
                
                if (availablePeriods.length === 0) {
                    throw new Error('No available periods found');
                }
                
                // Sort periods in descending order to get most recent first
                availablePeriods.sort((a, b) => b.localeCompare(a));
                
                // Find latest 5 dates with rejects across period files
                const latestDates = await findLatestDatesWithRejects(availablePeriods, 5);
                
                if (latestDates.length === 0) {
                    throw new Error('No dates with rejects found');
                }
                
                console.log("Found latest dates with rejects:", latestDates);
                
                // Sort dates in ascending order
                latestDates.sort((a, b) => new Date(a) - new Date(b));
                
                // Set date range from earliest to latest found date
                const startDate = new Date(latestDates[0]);
                const endDate = new Date(latestDates[latestDates.length - 1]);
                endDate.setHours(23, 59, 59, 999); // End of day
                
                console.log(`Auto-setting date range: ${startDate.toISOString()} to ${endDate.toISOString()}`);
                
                // Update UI with selected date range
                UIModule.setDateRange(startDate, endDate);
                
                // Set date range in data module
                DataModule.setDateRange(startDate, endDate);
                
                // Load data for the date range
                await DataModule.loadDataForDateRange();
                
                // Get filter options
                const filterOptions = DataModule.getFilterOptions();
                console.log("Available filter options:", filterOptions);
                
                // Populate filter dropdowns
                Object.keys(filterOptions).forEach(filterType => {
                    if (filterType !== 'actionSelection') {
                        UIModule.populateMultiSelect(`${filterType}-select`, filterOptions[filterType], []);
                    }
                });
                
                // Check available action selections and update UI
                const availableActions = DataModule.getAvailableActionSelections();
                UIModule.updateActionSelectionButtons(availableActions);
                
                // Ensure Final Inspection is set as the default station
                setDefaultStationToFinalInspection();
                
                // Update dashboard with loaded data
                updateDashboard();
                
                return true;
            } catch (error) {
                console.error('Error loading initial data:', error);
                return false;
            } finally {
                // Hide loading state
                document.getElementById('top-rejects-loading').style.display = 'none';
                document.getElementById('trend-chart-loading').style.display = 'none';
                document.getElementById('reasons-chart-loading').style.display = 'none';
            }
        };

        // Helper function to find the latest N dates with rejects across period files
        const findLatestDatesWithRejects = async function(periods, count) {
            let uniqueDates = new Set();
            let loadedPeriods = [];
            
            // Process each period until we find enough dates or run out of periods
            for (const period of periods) {
                try {
                    // Skip if we already have enough dates
                    if (uniqueDates.size >= count) break;
                    
                    console.log(`Checking period ${period} for reject dates...`);
                    
                    // Check if we've already loaded this period
                    if (!loadedPeriods.includes(period)) {
                        console.log(`Loading data for period ${period}...`);
                        const response = await fetch(`data/${period}.json`);
                        
                        if (!response.ok) {
                            console.warn(`Month data for ${period} not available or error: ${response.statusText}`);
                            continue;
                        }
                        
                        const periodData = await response.json();
                        const rejectData = periodData.rejectData || [];
                        
                        // Extract unique dates from this period's data
                        const datesInPeriod = new Set();
                        rejectData.forEach(item => {
                            if (item.ProductionDate) {
                                datesInPeriod.add(item.ProductionDate);
                            }
                        });
                        
                        console.log(`Found ${datesInPeriod.size} unique dates in period ${period}`);
                        
                        // Convert to array and sort in descending order (newest first)
                        const sortedDates = Array.from(datesInPeriod).sort((a, b) => 
                            new Date(b) - new Date(a)
                        );
                        
                        // Add dates to our collection, newest first, until we have enough
                        for (const date of sortedDates) {
                            uniqueDates.add(date);
                            if (uniqueDates.size >= count) break;
                        }
                        
                        // Mark this period as loaded
                        loadedPeriods.push(period);
                    }
                } catch (error) {
                    console.warn(`Error processing period ${period}:`, error);
                    continue;
                }
            }
            
            // Return the dates as a sorted array (newest first)
            return Array.from(uniqueDates).sort((a, b) => new Date(b) - new Date(a)).slice(0, count);
        };
        
        // Set default station to Final Inspection
        const setDefaultStationToFinalInspection = function() {
            // Get available stations
            const stations = DataModule.getAvailableStations();
            
            if (stations.length === 0) {
                return; // No stations available
            }
            
            // Find index of "Final Inspection" or any of its aliases
            let finalInspectionIndex = stations.findIndex(station => station === 'Final Inspection');
            
            // If Final Inspection isn't found by name, check for aliases
            if (finalInspectionIndex === -1) {
                for (const alias of DataModule.finalInspectionAliases) {
                    finalInspectionIndex = stations.findIndex(station => station === alias);
                    if (finalInspectionIndex !== -1) break;
                }
            }
            
            // If found, set current station index to Final Inspection
            if (finalInspectionIndex !== -1) {
                UIModule.setCurrentStationIndex(finalInspectionIndex);
                currentStationIndex = finalInspectionIndex;
            }
        };
        
        // Load data for changed date range
        const loadDataForDateRange = async function() {
            try {
                // Show loading state
                document.getElementById('top-rejects-loading').style.display = 'flex';
                document.getElementById('trend-chart-loading').style.display = 'flex';
                document.getElementById('reasons-chart-loading').style.display = 'flex';
                
                // Load data for current date range
                await DataModule.loadDataForDateRange();
                
                // Get filter options
                const filterOptions = DataModule.getFilterOptions();
                
                // Populate filter dropdowns with updated options
                Object.keys(filterOptions).forEach(filterType => {
                    if (filterType !== 'actionSelection') {
                        const currentFilters = DataModule.getCurrentFilters();
                        const selectedValues = currentFilters[filterType] || [];
                        
                        UIModule.populateMultiSelect(`${filterType}-select`, filterOptions[filterType], selectedValues);
                    }
                });
                
                // Check available action selections and update UI
                const availableActions = DataModule.getAvailableActionSelections();
                UIModule.updateActionSelectionButtons(availableActions);
                
                // Reset pagination
                UIModule.resetPagination();
                
                // Update dashboard with loaded data
                updateDashboard();
                
                return true;
            } catch (error) {
                console.error('Error loading data for date range:', error);
                return false;
            } finally {
                // Hide loading state
                document.getElementById('top-rejects-loading').style.display = 'none';
                document.getElementById('trend-chart-loading').style.display = 'none';
                document.getElementById('reasons-chart-loading').style.display = 'none';
            }
        };
        
        // Load comparison data
        const loadComparisonData = async function(period) {
            try {
                // Show loading state
                document.getElementById('trend-chart-loading').style.display = 'flex';
                
                // Load comparison data
                await DataModule.loadComparisonData(period);
                
                // Update trend chart with comparison data
                updateTrendChart();
                
                return true;
            } catch (error) {
                console.error('Error loading comparison data:', error);
                return false;
            } finally {
                // Hide loading state
                document.getElementById('trend-chart-loading').style.display = 'none';
            }
        };
        
        // Update dashboard with current data
        const updateDashboard = function(sortBy = UIModule.getCurrentSortBy()) {
            try {
                // Get metrics
                const metrics = DataModule.getMetricsSummary();
                UIModule.updateMetrics(metrics);
                
                // Update Final Inspection station card
                updateFinalInspectionCard();
                
                // Update top rejects table
                updateTopRejectsTable();
                
                // Update trend chart
                updateTrendChart();
                
                // Update reasons chart
                updateReasonsChart();
                
                return true;
            } catch (error) {
                console.error('Error updating dashboard:', error);
                return false;
            }
        };
        
        // Modified updateFinalInspectionCard function
        const updateFinalInspectionCard = function() {
            // Get current station index
            const stationIndex = UIModule.getCurrentStationIndex();
            currentStationIndex = stationIndex;
            
            // Get available stations
            const stations = DataModule.getAvailableStations();
            availableStations = stations;
            
            if (stations.length === 0) {
                // No stations available
                return;
            }
            
            // Get current station
            const currentStation = stations[stationIndex];
            
            // Get station data
            let stationData = {
                qty: 0,
                cost: 0
            };
            
            // If this is the Final Inspection station, get data from Final Inspection aliases
            if (currentStation === 'Final Inspection') {
                const finalInspectionData = DataModule.getFinalInspectionData();
                
                // Calculate totals
                finalInspectionData.forEach(item => {
                    stationData.qty += (item.QTY || 0);
                    stationData.cost += (item.Cost || 0);
                });
                
                // Get station reasons
                const reasonsPage = UIModule.getCurrentStationReasonsPage();
                const reasonsData = DataModule.getFinalInspectionReasons(UIModule.getCurrentSortBy(), reasonsPage);
                
                // Get the actual active Final Inspection stations based on current filters
                const activeStations = getActiveFinalInspectionStations();
                
                // Update title and show active stations
                const stationTitle = document.getElementById('station-title');
                const stationAliases = document.getElementById('station-aliases');
                
                if (stationTitle) {
                    stationTitle.textContent = 'Final Inspection';
                }
                
                if (stationAliases) {
                    if (activeStations.length > 0) {
                        stationAliases.textContent = `(${activeStations.join(', ')})`;
                        stationAliases.style.display = '';
                    } else {
                        stationAliases.style.display = 'none';
                    }
                }
                
                // Update UI with compact reasons format
                updateCompactReasons(reasonsData, stationData, stations);
            } else {
                // Get data for a regular station
                const filteredData = DataModule.getFilteredData();
                const stationItems = filteredData.filter(item => item.Station === currentStation);
                
                // Calculate totals
                stationItems.forEach(item => {
                    stationData.qty += (item.QTY || 0);
                    stationData.cost += (item.Cost || 0);
                });
                
                // Group by reasons
                const reasonsData = {};
                stationItems.forEach(item => {
                    const reason = item.RejectReason || 'Unknown';
                    
                    if (!reasonsData[reason]) {
                        reasonsData[reason] = {
                            reason,
                            qty: 0,
                            cost: 0,
                            parts: new Set()
                        };
                    }
                    
                    // Add parts
                    let parts = [];
                    if (Array.isArray(item.Parts)) {
                        parts = item.Parts.filter(p => p && p.trim());
                    } else if (typeof item.Parts === 'string') {
                        parts = item.Parts.split(',').map(p => p.trim()).filter(p => p);
                    }
                    
                    parts.forEach(part => {
                        if (part) reasonsData[reason].parts.add(part);
                    });
                    
                    // Accumulate qty and cost
                    reasonsData[reason].qty += (item.QTY || 0);
                    reasonsData[reason].cost += (item.Cost || 0);
                });
                
                // Convert to array and sort
                let reasonsArray = Object.values(reasonsData);
                
                // Sort by selected metric
                const sortBy = UIModule.getCurrentSortBy();
                if (sortBy === 'qty') {
                    reasonsArray.sort((a, b) => b.qty - a.qty);
                } else {
                    reasonsArray.sort((a, b) => b.cost - a.cost);
                }
                
                // Format parts as comma-separated string
                reasonsArray = reasonsArray.map(item => ({
                    ...item,
                    parts: Array.from(item.parts).join(', ')
                }));
                
                // Calculate pagination
                const pageSize = 3;
                const reasonsPage = UIModule.getCurrentStationReasonsPage();
                const totalRecords = reasonsArray.length;
                const totalPages = Math.ceil(totalRecords / pageSize);
                const offset = (reasonsPage - 1) * pageSize;
                
                // Apply pagination
                const paginatedData = reasonsArray.slice(offset, offset + pageSize);
                
                // Prepare data structure for UI
                const reasonsDataObj = {
                    data: paginatedData,
                    pagination: {
                        page: reasonsPage,
                        pageSize,
                        totalRecords,
                        totalPages
                    }
                };
                
                // Update station title (for regular stations)
                const stationTitle = document.getElementById('station-title');
                const stationAliases = document.getElementById('station-aliases');
                
                if (stationTitle) {
                    stationTitle.textContent = currentStation;
                }
                
                if (stationAliases) {
                    stationAliases.style.display = 'none';
                }
                
                // Update UI with compact reasons format
                updateCompactReasons(reasonsDataObj, stationData, stations);
            }
        };

        // Helper function to get active Final Inspection stations based on filters
        const getActiveFinalInspectionStations = function() {
            const finalInspectionAliases = DataModule.finalInspectionAliases;
            const filteredData = DataModule.getFilteredData();
            
            // Get unique stations that match the aliases
            const activeStations = new Set();
            
            filteredData.forEach(item => {
                if (item.Station && finalInspectionAliases.includes(item.Station)) {
                    activeStations.add(item.Station);
                }
            });
            
            return Array.from(activeStations);
        };

        // Update the station card with compact reasons format
        const updateCompactReasons = function(reasonsData, stationData, stationsList) {
            const { data: reasons, pagination } = reasonsData;
            
            // Update metrics
            if (elements.finalInspectionQty) {
                elements.finalInspectionQty.textContent = stationData.qty.toLocaleString();
            }
            
            if (elements.finalInspectionCost) {
                elements.finalInspectionCost.textContent = Utils.formatCurrency(stationData.cost);
            }
            
            // Update reasons list with compact format
            if (elements.stationReasonsContainer) {
                elements.stationReasonsContainer.innerHTML = '';
                
                if (reasons && reasons.length > 0) {
                    reasons.forEach(reason => {
                        const reasonItem = document.createElement('div');
                        reasonItem.className = 'reason-item';
                        
                        // Info section with reason name and parts
                        const reasonInfo = document.createElement('div');
                        reasonInfo.className = 'reason-info';
                        
                        // Main reason section with name
                        const reasonName = document.createElement('div');
                        reasonName.className = 'reason-name';
                        reasonName.title = reason.reason;
                        reasonName.textContent = Utils.truncateText(reason.reason, 20);
                        
                        // Parts section below
                        const reasonParts = document.createElement('div');
                        reasonParts.className = 'reason-parts';
                        reasonParts.title = reason.parts;
                        reasonParts.textContent = `Parts: ${Utils.truncateText(reason.parts, 30)}`;
                        reasonParts.style.fontSize = '0.75rem';
                        reasonParts.style.color = 'var(--text-muted)';
                        
                        reasonInfo.appendChild(reasonName);
                        reasonInfo.appendChild(reasonParts);
                        
                        // Values section with qty and cost
                        const reasonValue = document.createElement('div');
                        reasonValue.className = 'reason-value';
                        reasonValue.title = `Qty: ${reason.qty}, Cost: ${Utils.formatCurrency(reason.cost)}`;
                        reasonValue.textContent = `${reason.qty} (${Utils.formatCurrency(reason.cost)})`;
                        
                        reasonItem.appendChild(reasonInfo);
                        reasonItem.appendChild(reasonValue);
                        
                        elements.stationReasonsContainer.appendChild(reasonItem);
                    });
                } else {
                    const emptyReasons = document.createElement('div');
                    emptyReasons.className = 'empty-text';
                    emptyReasons.textContent = 'No reasons data available';
                    elements.stationReasonsContainer.appendChild(emptyReasons);
                }
            }
            
            // Update reasons pagination
            if (elements.stationReasonsPagination) {
                elements.stationReasonsPagination.innerHTML = '';
                
                if (pagination && pagination.totalPages > 1) {
                    for (let i = 1; i <= pagination.totalPages; i++) {
                        const pageBtn = document.createElement('button');
                        pageBtn.className = `station-page-btn ${i === pagination.page ? 'active' : ''}`;
                        pageBtn.dataset.page = i;
                        pageBtn.textContent = i;
                        elements.stationReasonsPagination.appendChild(pageBtn);
                    }
                }
            }
            
            // Update station navigation
            availableStations = stationsList;
            
            if (elements.stationCurrent && elements.stationTotal) {
                elements.stationCurrent.textContent = currentStationIndex + 1;
                elements.stationTotal.textContent = availableStations.length;
            }
            
            if (elements.prevStationBtn && elements.nextStationBtn) {
                elements.prevStationBtn.disabled = currentStationIndex <= 0;
                elements.nextStationBtn.disabled = currentStationIndex >= availableStations.length - 1;
            }
        };
        
        // Update top rejects table
        const updateTopRejectsTable = function() {
            // Get current page
            const page = UIModule.getCurrentTopRejectsPage();
            
            // Get sort method
            const sortBy = UIModule.getCurrentSortBy();
            
            // Get current filters
            const currentFilters = DataModule.getCurrentFilters();
            
            // Check if RTS filter is active
            const isRtsSelected = currentFilters.actionSelection && 
                                 currentFilters.actionSelection.length === 1 && 
                                 currentFilters.actionSelection[0] === 'RTS';
            
            // Get top rejects data
            const topRejects = DataModule.getTopRejects(5, sortBy, page);
            
            // Update UI
            UIModule.updateTopRejectsTable(topRejects, isRtsSelected);
        };
        
        // Update trend chart
        const updateTrendChart = function() {
            // Get trend view (qty or cost)
            const trendView = UIModule.getCurrentTrendView();
            
            // Get trend data
            const trendData = DataModule.getTrendChartData(trendView);
            
            // Check if comparison is selected
            const comparisonPeriod = UIModule.getSelectedComparisonPeriod();
            let comparisonData = null;
            
            if (comparisonPeriod !== 'none') {
                comparisonData = DataModule.getComparisonTrendData(trendView);
            }
            
            // Create chart
            ChartModule.createTrendChart(trendData, comparisonData, trendView);
        };
        
        // Update reasons chart
        const updateReasonsChart = function() {
            // Get reasons view (qty or cost)
            const reasonsView = UIModule.getCurrentReasonsView();
            
            // Get reasons data
            const reasonsData = DataModule.getTopReasons(5, reasonsView);
            
            // Create chart
            ChartModule.createReasonsChart(reasonsData, reasonsView);
        };
        
        // Return public methods
        return {
            init,
            loadDataForDateRange,
            loadComparisonData,
            updateDashboard,
            updateFinalInspectionCard,
            updateTopRejectsTable,
            updateTrendChart,
            updateReasonsChart
        };
    })();

    // Initialize the dashboard when the document is ready
    document.addEventListener('DOMContentLoaded', () => {
        // Use the try-catch block to handle any errors during initialization
        try {
            DashboardModule.init().then(success => {
                if (!success) {
                    console.error("Dashboard initialization failed");
                }
            });
        } catch (error) {
            console.error("Fatal error during dashboard initialization:", error);
        }
    });
    </script>
</body>
</html>
